<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LLCryptoLib</name>
    </assembly>
    <members>
        <member name="T:LLCryptoLib.Security.SspiProvider">
            <summary>
            Defines the external methods of the CryptoAPI.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Resources.SecurityServicesMessages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_AcquireCSP">
            <summary>
              Looks up a localized string similar to Couldn&apos;t acquire crypto service provider context..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_AlgNotSupp">
            <summary>
              Looks up a localized string similar to The Cryptographic Service Provider does not support the selected algorithm..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_BigKey">
            <summary>
              Looks up a localized string similar to The key is too big..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_CannotReadSeekWrite">
            <summary>
              Looks up a localized string similar to The stream does not support reading, writing or seeking..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_CredentialDelete">
            <summary>
              Looks up a localized string similar to An error occurred while trying to delete the credential (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_CredentialEnumeration">
            <summary>
              Looks up a localized string similar to An error occurred while trying to enumerate the credentials (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_CredentialMaxPersistence">
            <summary>
              Looks up a localized string similar to An error occurred while trying to get the maximum credential persistence level (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_CredentialRead">
            <summary>
              Looks up a localized string similar to An error occurred while trying to read the credential (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_CredentialRename">
            <summary>
              Looks up a localized string similar to An error occurred while trying to rename the credential (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_CredentialWrite">
            <summary>
              Looks up a localized string similar to An error occurred while writing the credential (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_Decrypt">
            <summary>
              Looks up a localized string similar to An error occurred while decrypting the data..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_Disposed">
            <summary>
              Looks up a localized string similar to The specified object has been disposed..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_Encrypt">
            <summary>
              Looks up a localized string similar to An error occurred while encrypting the data..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_EnumEnded">
            <summary>
              Looks up a localized string similar to The enumeration has finished..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_EnumNotStarted">
            <summary>
              Looks up a localized string similar to The enumeration has not been initialized yet..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_GetKeyParams">
            <summary>
              Looks up a localized string similar to Cannot retrieve the key parameters..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_HashData">
            <summary>
              Looks up a localized string similar to The data could not be hashed..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_HashRead">
            <summary>
              Looks up a localized string similar to The hash value could not be read..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_InvalidCipherMode">
            <summary>
              Looks up a localized string similar to The specified cipher mode is invalid..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_InvalidHash">
            <summary>
              Looks up a localized string similar to The message hash does not correspond to the message body..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_InvalidIVSize">
            <summary>
              Looks up a localized string similar to The specified IV is invalid..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_InvalidKeySize">
            <summary>
              Looks up a localized string similar to The specified key is invalid..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_InvalidPaddingMode">
            <summary>
              Looks up a localized string similar to The specified padding mode is invalid..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_InvalidXMLBadVersion">
            <summary>
              Looks up a localized string similar to The version number embedded in the XML string is invalid..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_KeyExport">
            <summary>
              Looks up a localized string similar to Unable to export the key..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_KeygenFailed">
            <summary>
              Looks up a localized string similar to An error occurred while generating a cryptographic key..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_KeyImport">
            <summary>
              Looks up a localized string similar to Unable to import the key..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_KeyLength">
            <summary>
              Looks up a localized string similar to Unable to get the key length..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_NotAPermissionElement">
            <summary>
              Looks up a localized string similar to The XML element was not a permission element..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_ParamInvalid">
            <summary>
              Looks up a localized string similar to The specified parameter is invalid..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_ParamNull">
            <summary>
              Looks up a localized string similar to The specified parameter is a null reference..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_ParamOutOfRange">
            <summary>
              Looks up a localized string similar to The parameter was out of range..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_PrivateKeyAlg">
            <summary>
              Looks up a localized string similar to Unable to get the private key&apos;s algorithm..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_Randomizer">
            <summary>
              Looks up a localized string similar to Could not generate random data..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_RequiresFIPS">
            <summary>
              Looks up a localized string similar to The requested algorithm is not FIPS validated..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SetKeyParams">
            <summary>
              Looks up a localized string similar to Cannot set the key parameters..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardAlreadyConnected">
            <summary>
              Looks up a localized string similar to A connection to a smartcard has already been established..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardConnect">
            <summary>
              Looks up a localized string similar to An error occurred while trying to connect to the smartcard (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardEstablishContext">
            <summary>
              Looks up a localized string similar to An error occurred while trying to establish the smartcard reader context (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardGetAttributes">
            <summary>
              Looks up a localized string similar to An error occurred while retrieving the attributes from the card reader (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardGetStatus">
            <summary>
              Looks up a localized string similar to An error occurred while refreshing the smartcard reader status (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardLock">
            <summary>
              Looks up a localized string similar to An error occurred while trying to lock the smartcard (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardNotConnected">
            <summary>
              Looks up a localized string similar to A connection to a smartcard is required..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardReconnect">
            <summary>
              Looks up a localized string similar to An error occurred while trying to reconnect to the smartcard (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardTransmit">
            <summary>
              Looks up a localized string similar to An error occurred while sending data to the smartcard (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_SmartcardUnlock">
            <summary>
              Looks up a localized string similar to An error occurred while trying to unlock the smartcard (error code {0}, error message &quot;{1}&quot;)..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_Transform">
            <summary>
              Looks up a localized string similar to An error occurred while transforming the data..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Error_UnsupportedOS">
            <summary>
              Looks up a localized string similar to Your operating system is too old. {0} or higher is required..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Info_DeviceSerial">
            <summary>
              Looks up a localized string similar to Serial Number: {0}.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Info_DeviceType">
            <summary>
              Looks up a localized string similar to Device Type: {0}.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Info_DeviceVendor">
            <summary>
              Looks up a localized string similar to Vendor: {0}.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.Info_DeviceVersion">
            <summary>
              Looks up a localized string similar to Version: {0}.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.PinForm_Cancel">
            <summary>
              Looks up a localized string similar to Cancel.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.PinForm_Caption">
            <summary>
              Looks up a localized string similar to Enter your PIN....
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.PinForm_Description">
            <summary>
              Looks up a localized string similar to Please enter the PIN of your smartcard..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.PinForm_InvalidPin">
            <summary>
              Looks up a localized string similar to The PIN you entered is invalid. It contains illegal characters, or is of a wrong length. Please try again..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.PinForm_InvalidPinTitle">
            <summary>
              Looks up a localized string similar to Invalid PIN....
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.PinForm_OK">
            <summary>
              Looks up a localized string similar to OK.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.PinForm_PIN">
            <summary>
              Looks up a localized string similar to PIN:.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_Cancel">
            <summary>
              Looks up a localized string similar to Cancel.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_Caption">
            <summary>
              Looks up a localized string similar to Select reader....
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_Description">
            <summary>
              Looks up a localized string similar to Please select the smartcard reader you wish to use..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_Details">
            <summary>
              Looks up a localized string similar to Details.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_Inserted">
            <summary>
              Looks up a localized string similar to Available smartcard:.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_NoCard">
            <summary>
              Looks up a localized string similar to No card.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_NoCardDesc">
            <summary>
              Looks up a localized string similar to There is no card in the smartcard reader..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_NoReaders">
            <summary>
              Looks up a localized string similar to No smartcard readers have been found on this system..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_NoReadersTitle">
            <summary>
              Looks up a localized string similar to No readers....
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_OK">
            <summary>
              Looks up a localized string similar to OK.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_Readers">
            <summary>
              Looks up a localized string similar to Smartcard readers:.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_Status">
            <summary>
              Looks up a localized string similar to Smartcard status:.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_UnknownCard">
            <summary>
              Looks up a localized string similar to Unknown card.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_UnknownCardDesc">
            <summary>
              Looks up a localized string similar to The inserted card is of an unknown type..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_UnknownStatus">
            <summary>
              Looks up a localized string similar to Unknown status.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_UnknownStatusDesc">
            <summary>
              Looks up a localized string similar to The status of the smartcard reader is unknown..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_ValidCard">
            <summary>
              Looks up a localized string similar to Valid card.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Resources.SecurityServicesMessages.SelectReaderForm_ValidCardDesc">
            <summary>
              Looks up a localized string similar to The inserted card is a valid smart card..
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.ParallelHash">
            <summary>Computes Parallel hashes for the input data using the managed libraries.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.ParallelHash.#ctor(System.Security.Cryptography.HashAlgorithm[])">
            <summary>Initializes an instance of ParellelHash.</summary>
            <param name="hashers">The list of HashAlgorithms to use in the calculations.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.ParallelHash.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.ParallelHash.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Performs the hash algorithm on the data provided.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.ParallelHash.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.CRC">
            <summary>Computes the CRC hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC.#ctor(LLCryptoLib.Hash.CRCParameters)">
            <summary>Initializes a new instance of the CRC class.</summary>
            <param name="param">The parameters to utilize in the CRC calculation.</param>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC.BuildLookup(LLCryptoLib.Hash.CRCParameters)">
            <summary>Build the CRC lookup table for a given polynomial.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC.Reflect(System.Int64,System.Int32)">
            <summary>Reflects the lower bits of the value provided.</summary>
            <param name="data">The value to reflect.</param>
            <param name="numBits">The number of bits to reflect.</param>
            <returns>The reflected value.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.Adler32">
            <summary>Computes the Adler-32 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Adler32.#ctor">
            <summary>Initializes a new instance of the Adler32 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Adler32.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Adler32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Performs the hash algorithm on the data provided.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Adler32.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextRijndael">
            <summary>
            Rijndael encryption class for text
            </summary>
            <example>
            <code>
            TextAlgorithmParameters parms = new TextAlgorithmParameters("llcryptopassword");
            TextCrypter textEncrypter = new TextCrypter(new TextRijndael(parms));
            encrypted = textEncrypter.Base64EncryptDecrypt(origString, true);
            Console.WriteLine("Encrypted string: " + encrypted);
            decrypted = textEncrypter.Base64EncryptDecrypt(encrypted, false);
            Console.WriteLine("Decrypted string: " + decrypted);
            </code>
            </example>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextAlgorithm">
            <summary>
            TextAlgorithm
            The 'TextAlgorithm' perform these conversions in the crypting phase:
            - Text in clear is converted into array of bytes with 'StringToBytes'
            - Bytes are passed to encryption algorithm
            - Encryption algorithm returns a MemoryStream
            - MemoryStream is turned into a Base64 string with 'MemoryToBase64String'
            And these when decrypting:
            - Text must be in Base64 in order to be decrypted
            - Base64 string is turned into bytes with 'Base64StringToBytes'
            - Bytes are passed to decryption algorithm
            - Decryption returns a MemoryStream
            - MemoryStream is turned into clear text with 'MemoryToString'
            To create a TextAlgorithm see, for instance, TextROT13 <see cref="T:LLCryptoLib.Crypto.TextROT13"/>
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.TextAlgorithm.maKey">
            <summary>
            Text Algorithm byte key
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.TextAlgorithm.maIV">
            <summary>
            Text Algorithm inizialization vector
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithm.#ctor(LLCryptoLib.Crypto.TextAlgorithmType)">
            <summary>
            Constructor
            </summary>
            <param name="type">If it's a binary or text algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithm.Code(System.String)">
            <summary>
            Encryption text algorithm
            </summary>
            <param name="txt">String to be encrypted</param>
            <returns>Encrypted string</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithm.Decode(System.String)">
            <summary>
            Decryption text algorithm
            </summary>
            <param name="txt">String to decrypted</param>
            <returns>Decrypted string</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithm.GenerateKey(System.String,System.Int16,System.Int16)">
            <summary>
            Generates a key and an initialization value.
            Max size is 32 = keySize+blockSize
            </summary>
            <param name="secretPhrase">Passphrase</param>
            <param name="keySize">Algorithm TextVigenere Size in bytes</param>
            <param name="blockSize">Algorithm Block (and IV) Size in bytes</param>
            <exception cref="T:LLCryptoLib.LLCryptoLibException"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.TextAlgorithm.Type">
            <summary>
            Text algorithm type. If it's a normal text algorithm (ie: TextROT13)
            then this will be TextAlgorithm.Text. If it's a binary algorithm
            turned into a text algorithm via Base64 conversions, this will be
            TextAlgorithm.Binary
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextRijndael.#ctor(LLCryptoLib.Crypto.TextAlgorithmParameters)">
            <summary>
            Rijndael encryption class constructor
            </summary>
            <param name="p">Parametri (key and shift)</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextRijndael.Code(System.String)">
            <summary>
            Code using Rijndael algoritml
            </summary>
            <param name="txt">String text to code (text must be UTF8 compatible)</param>
            <returns>Base64 representation of text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextRijndael.Decode(System.String)">
            <summary>
            Decode using Rijndael algorithm
            </summary>
            <param name="txt"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextRijndael.EncryptData(System.Byte[],System.Boolean)">
            <summary>
            Encrypts/Decrypts using Rijndael algorithm
            </summary>
            <param name="txt">Bytes to crypt/decrypt in bytes</param>
            <param name="isCrypting">If true, crypt, else decrypt</param>
            <returns></returns>
        </member>
        <member name="P:LLCryptoLib.Crypto.TextRijndael.KeySize">
            <summary>
            Length of the key in bits
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.TextRijndael.BlockSize">
            <summary>
            Length of the block in bits
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextCryptEngine">
            <summary>
            A TextCryptEngine is a transformation box that takes in input
            a string and returns a transformed string in output.
            The main method that do this is Transform(algorithm, crypt/decrypt).
            The engine applies algorithms by polymorphically apply the
            Code and Decode methods of an ITextEncryption object.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCryptEngine.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="text">Text to crypt/decrypt</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCryptEngine.Transform(LLCryptoLib.Crypto.TextAlgorithm,System.Boolean)">
            <summary>
            Encrypt/decrypt a string, given a crypto method, into a scrambled text string.
            If the method is a text method (TextROT13, TextPlayfair, TextVigenere...) the coded
            string is text. If the method is a byte method (DES, Rijndael) the coded string
            is a Base64 string.
            </summary>
            <param name="mtd">Crypto method (shift, key, des...)</param>
            <param name="codeDecode">If true, code; else, decode</param>
            <returns>Transformed string</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCryptEngine.HexTransform(LLCryptoLib.Crypto.TextAlgorithm,System.Boolean,LLCryptoLib.HexStyle)">
            <summary>
            Encrypt or decrypt a string, given a crypto method, into a series of hex numbers
            </summary>
            <param name="algo">Crypto method (shift, key, des...)</param>
            <param name="codeDecode">If true, code; else, decode</param>
            <param name="style">Style of hexadecimal output</param>
            <returns>Transformed string</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamARC4Base">
            <summary>
            Base class for all ARC4 classes
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamAlgorithm">
            <summary>
            Encryption Algorithm.
            A StreamAlgorithm class indicates the algorithm to be used in Stream Encryption.
            <see cref="T:LLCryptoLib.Crypto.StreamCrypter"/>
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            StreamAlgorithm encryptAlgo = new StreamAES256();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="T:LLCryptoLib.Crypto.IStreamAlgorithm">
            <summary>
            IStreamAlgorithm. This is the base interface for file based/stream based encryption.
            </summary>
            <example>
            Encryption and decryption using stream algorithms:
            <code>
            // 1. Set algorithm
            IStreamAlgorithm cryptoAlgo = StreamAlgorithmFactory.Create(SupportedStreamAlgorithms.BLOWFISH);
            // 2. Encrypt 
            StreamCrypter crypter = new StreamCrypter(cryptoAlgo);
            crypter.GenerateKeys("littlelitesoftware");
            crypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            // 3. Decrypt
            StreamCrypter decrypter = new StreamCrypter(cryptoAlgo);
            crypter.GenerateKeys("littlelitesoftware");
            crypter.EncryptDecrypt(encryptedFile, decryptedFile, false, null);
            Console.WriteLine("File decrypted into " + decryptedFile);
            </code></example>
        </member>
        <member name="P:LLCryptoLib.Crypto.IStreamAlgorithm.SupportedAlgorithmID">
            <summary>
            The algorithm as an enum constant
            </summary>
            <see cref="T:LLCryptoLib.Crypto.SupportedStreamAlgorithms"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.IStreamAlgorithm.Algorithm">
            <summary>
            The algorithm as defined in System.Security.Cryptography
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.IStreamAlgorithm.BlockLen">
            <summary>
            Length of block in bytes
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.IStreamAlgorithm.KeyLen">
            <summary>
            Length of key in bytes
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.StreamAlgorithm.pBlockLen">
            <summary>
            Block length
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.StreamAlgorithm.pKeyLen">
            <summary>
            Key Length
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.StreamAlgorithm.description">
            <summary>
            Algorithm description
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAlgorithm.#ctor(System.Int16,System.Int16,System.String)">
            <summary>
            Stream algorithm constructor.
            </summary>
            <param name="eaKeyLen">Length of key in bytes</param>
            <param name="eaBlockLen">Length of block in bytes</param>
            <param name="eaDescription">Syntetic description of algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAlgorithm.ToString">
            <summary>
            Returns a <see cref="T:System.String">string</see> that represents the current <see cref="T:System.Object">StreamAlgorithm</see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithm.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithm.KeyLen">
            <summary>
            Length of key in bytes
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithm.BlockLen">
            <summary>
            Length of block in bytes
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithm.SupportedAlgorithmID">
            <summary>
            The algorithm ID as in SupportedStreamAlgorithms
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithm.Algorithm">
            <summary>
            The algorithm as defined in System.Security.Cryptography
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.StreamARC4Base.ARC4BLOCK">
            <summary>
            Size of block for all ARC4 algorithms.
            This is different in MONO and .NET.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamARC4Base.#ctor(System.Int16,System.Int16,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Crypto.StreamARC4Base"/> class.
            </summary>
            <param name="eaKeyLen">Length of key in bytes</param>
            <param name="eaBlockLen">Length of block in bytes</param>
            <param name="eaDescription">Syntetic description of algorithm</param>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamARC4Base.Algorithm">
            <summary>
            Returns an ARC4 object implementation
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamARC4Base.SupportedAlgorithmID">
            <summary>
            The algorithm ID as in SupportedStreamAlgorithms
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamARC4">
            <summary>
            ARC4 128bit.
            ARC4 is short for `Alleged RC4'. The real RC4 algorithm is proprietary to RSA Data Security Inc. 
            In September 1994, someone posted C code to both the Cypherpunks mailing list and to the Usenet 
            newsgroup @code{sci.crypt}, claiming that it implemented the RC4 algorithm. 
            This posted code is what it being called Alleged RC4, or ARC4 for short. 
            ARC4 is a private-key cipher; the same key is used to both encrypt and decrypt. 
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamARC4();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamARC4.#ctor">
            <summary>
            ARC4 128 bit constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamARC4.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.ARC4
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamARC4512">
            <summary>
            ARC4 algorithm at 512bit
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamARC4512();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamARC4512.#ctor">
            <summary>
            Arc4 512 bit constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamARC4512.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.ARC4512
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamARC41024">
            <summary>
            ARC4 1024bit
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamARC41024();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamARC41024.#ctor">
            <summary>
            Arc4 1024 bit constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamARC41024.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.ARC41024
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamARC42048">
            <summary>
            ARC4 2048bit
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamARC42048();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamARC42048.#ctor">
            <summary>
            Arc4 2048 constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamARC42048.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.ARC42048
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.BlowfishECB">
            <summary>Blowfish ECB implementation.</summary>
            <remarks>Use this class to encrypt or decrypt byte arrays or a single
            block with Blowfish in the ECB (Electronic Code Book) mode. The key
            length can be flexible from zero up to 56 bytes.</remarks>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.MAX_KEY_LENGTH">
            <summary>The maximum and recommended key size in bytes.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.BLOCK_SIZE">
            <summary>The block size in bytes.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.pbox">
            <summary>Runtime p-box.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.sbox1">
            <summary>Runtime s-box #1.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.sbox2">
            <summary>Runtime s-box #2.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.sbox3">
            <summary>Runtime s-box #3.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.sbox4">
            <summary>Runtime s-box #4.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.block">
            <summary>Single block cache.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.isWeakKey">
            <summary>1 if a weak key was detected, 0 if not and -1 if it hasn't
            been determined yet.</summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.Initialize(System.Byte[],System.Int32,System.Int32)">
            <summary>Resets the instance with new or initial key material. Allows the switch of
            keys at runtime without any new internal object allocation.</summary>
            <param name="key">The buffer with the key material.</param>
            <param name="ofs">Position at which the key material starts in the buffer.</param>
            <param name="len">Size of the key material, up to MAX_KEY_LENGTH bytes.</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.#ctor">
            <summary>Zero constructor, properly initializes an instance. Initialize afterwards
            to set up a valid key!</summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.#ctor(System.Byte[],System.Int32,System.Int32)">
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.Initialize(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.Invalidate">
            <summary> Deletes all internal data structures and invalidates this instance.</summary>
            <remarks>Call this method as soon as the work with a particular instance is done,
            so no sensitive translated key material remains. The instance is invalid after this
            call and usage can lead to unexpected results!</remarks> 
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.RunSelfTest">
            <summary>To execute a selftest.</summary>
            <remarks>Call this method to make sure that the implemenation is able to produce
            valid output according to the specification. This should usually be done at process
            startup time, before the usage of this class and its inherited variants.</remarks>
            <returns>True if the selftest passed or false is it failed. In such a case you must
            not use the cipher to avoid data corruption!</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.EncryptBlock(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>Encrypts a single block.</summary>
            <param name="hi">The high 32bit word of the block.</param>
            <param name="lo">The low 32bit word of the block.</param>
            <param name="outHi">Where to put the encrypted high word.</param>
            <param name="outLo">Where to put the encrypted low word.</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.DecryptBlock(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>Decrypts a single block.</summary>
            <param name="hi">The high 32bit word of the block.</param>
            <param name="lo">The low 32bit word of the block.</param>
            <param name="outHi">Where to put the decrypted high word.</param>
            <param name="outLo">Where to put the decrypted low word.</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.Encrypt(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Encrypts byte buffers.</summary>
            <remarks>Use this method to encrypt bytes from one array to another one. You can also 
            use the same array for input and output. Note that the number of bytes must be adjusted
            to the block size of the algorithm. Overlapping bytes will not be encrypted. No check for
            buffer overflows are made.</remarks>
            <param name="dataIn">The input buffer.</param>
            <param name="posIn">Where to start reading in the input buffer.</param>
            <param name="dataOut">The output buffer.</param>
            <param name="posOut">Where to start writing to the output buffer.</param>
            <param name="count">The number ob bytes to encrypt.</param>
            <returns>The number of bytes processed.</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.Decrypt(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Decrypts single bytes.</summary>
            <remarks>Use this method to decrypt bytes from one array to another one. You can also use
            the same array for input and output. Note that the number of bytes must be adjusted to the
            block size of the algorithm. Overlapping bytes will not be decrypted. No check for buffer
            overflows are made.</remarks>
            <param name="dataIn">The input buffer.</param>
            <param name="posIn">Where to start reading in the input buffer.</param>
            <param name="dataOut">The output buffer.</param>
            <param name="posOut">Where to start writing to the output buffer.</param>
            <param name="count">Number ob bytes to decrypt.</param>
            <returns>The number of bytes processed.</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishECB.Clone">
            <remarks>Cloning can be very useful if you need multiple instances all using
            the same key, since the expensive cipher setup will be bypassed.</remarks>
            <see cref="M:System.ICloneable.Clone"/>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.PBOX_INIT">
            <summary>The P-box initialization data.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.SBOX_INIT_1">
            <summary>The first S-box initialization data.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.SBOX_INIT_2">
            <summary>The second S-box initialization data.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.SBOX_INIT_3">
            <summary>The third S-box initialization data.</summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.BlowfishECB.SBOX_INIT_4">
            <summary>The fourth S-box initialization data.</summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishECB.IsWeakKey">
            <summary>To check if the key used is weak.</summary>
            <remarks>If a key is weak i means that eventually an attack is easier to apply than
            just a simple brute force on keys. Due to the randomness in the key setup process
            such a case however is unlikely to happen, yet checking after each setup might still
            be the preferred way. In the case of a weak key detected a simple recreation with a
            different key (or just a different salt value) is the recommended soltution. For
            performance reasons we don't do the weak key check during the initialization, but on
            demand only, and then only once to determine the flag.</remarks>
        </member>
        <member name="T:LLCryptoLib.Crypto.BlowfishCBC">
            <summary>Blowfish CBC implementation.</summary>
            <remarks>Use this class to encrypt or decrypt byte arrays or a single blocks
            with Blowfish in CBC (Cipher Block Block Chaining) mode. This is the recommended
            way to use Blowfish.NET, unless certain requirements (e.g. moving block without
            decryption) exist.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.SetIV(System.Byte[],System.Int32)">
            <summary>Sets the initialization vector (IV) with an offset.</summary>
            <param name="buf">The buffer containing the new IV material.</param>
            <param name="ofs">Where the IV material starts.</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.GetIV(System.Byte[],System.Int32)">
            <summary>Gets the current IV material (of the size of one block).</summary>
            <param name="buf">The wuffer to copy the IV to.</param>
            <param name="ofs">Where to start copying.</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Default constructor.
            </summary>
            <param name="key">The key.</param>
            <param name="ofs">The ofs.</param>
            <param name="len">The len.</param>
            <remarks>The IV needs to be assigned after the instance has been created!</remarks>
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.Initialize(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.#ctor">
            <summary>
            Zero key constructor.
            </summary>
            <remarks>After construction you need to initialize the instance and then apply the IV.</remarks>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.Invalidate">
            <summary>
            Deletes all internal data structures and invalidates this instance.
            </summary>
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.Invalidate"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.EncryptBlock(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>
            Encrypts a single block.
            </summary>
            <param name="hi">The high 32bit word of the block.</param>
            <param name="lo">The low 32bit word of the block.</param>
            <param name="outHi">Where to put the encrypted high word.</param>
            <param name="outLo">Where to put the encrypted low word.</param>
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.EncryptBlock(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@)"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.DecryptBlock(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>
            Decrypts a single block.
            </summary>
            <param name="hi">The high 32bit word of the block.</param>
            <param name="lo">The low 32bit word of the block.</param>
            <param name="outHi">Where to put the decrypted high word.</param>
            <param name="outLo">Where to put the decrypted low word.</param>
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.DecryptBlock(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@)"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.Encrypt(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypts byte buffers.
            </summary>
            <param name="dataIn">The input buffer.</param>
            <param name="posIn">Where to start reading in the input buffer.</param>
            <param name="dataOut">The output buffer.</param>
            <param name="posOut">Where to start writing to the output buffer.</param>
            <param name="count">The number ob bytes to encrypt.</param>
            <returns>The number of bytes processed.</returns>
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.Encrypt(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.Decrypt(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decrypts single bytes.
            </summary>
            <param name="dataIn">The input buffer.</param>
            <param name="posIn">Where to start reading in the input buffer.</param>
            <param name="dataOut">The output buffer.</param>
            <param name="posOut">Where to start writing to the output buffer.</param>
            <param name="count">Number ob bytes to decrypt.</param>
            <returns>The number of bytes processed.</returns>
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.Decrypt(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishCBC.Clone">
            <summary>
            Clone
            </summary>
            <returns></returns>
            <see cref="M:LLCryptoLib.Crypto.BlowfishECB.Clone"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishCBC.IV">
            <summary>The current initialization vector (IV), which measures one block.</summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.BlowfishManaged">
            <summary>Implementation of the Blowfish algorithm as a standard component for
            the .NET security framework.</summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishManaged.#ctor">
            <summary>Default constructor. Starts as an uninitialized ECB instance.</summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishManaged.CreateEncryptor(System.Byte[],System.Byte[])">
            <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishManaged.CreateDecryptor(System.Byte[],System.Byte[])">
            <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishManaged.GenerateKey">
            <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishManaged.GenerateIV">
            <see cref="M:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishManaged.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <see cref="M:System.Security.Cryptography.ICryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.BlowfishManaged.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <see cref="M:System.Security.Cryptography.ICryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.BlockSize">
            <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.BlockSize"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.IV">
            <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.Key">
            <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Key"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.KeySize">
            <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.KeySize"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.Mode">
            <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.Mode"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.CanReuseTransform">
            <see cref="P:System.Security.Cryptography.ICryptoTransform.CanReuseTransform"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.CanTransformMultipleBlocks">
            <see cref="P:System.Security.Cryptography.ICryptoTransform.CanTransformMultipleBlocks"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.InputBlockSize">
            <see cref="P:System.Security.Cryptography.ICryptoTransform.InputBlockSize"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.BlowfishManaged.OutputBlockSize">
            <see cref="P:System.Security.Cryptography.ICryptoTransform.OutputBlockSize"/>
        </member>
        <member name="T:LLCryptoLib.Utils.OS">
            <summary>
            Operating System class
            </summary>
        </member>
        <member name="P:LLCryptoLib.Utils.OS.OperatingSystem">
            <summary>
            Return the Operating System information
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.StringEncryption">
            <summary>
            Defines a number of easy-to-use methods to perform string-based encryption.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.#ctor">
            <summary>
            Initializes a new StringEncryption instance.
            </summary>
            <remarks>The default bulk cipher algorithm is Rijndael and the default hash algorithm is RIPEMD-160.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.#ctor(System.String,System.String)">
            <summary>
            Initializes a new StringEncryption instance.
            </summary>
            <param name="bulkCipher">The name of the bulk cipher algorithm to use.</param>
            <param name="hash">The name of the hash algorithm to use.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.#ctor(System.Security.Cryptography.SymmetricAlgorithm,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Initializes a new StringEncryption instance.
            </summary>
            <param name="bulkCipher">The bulk cipher algorithm to use.</param>
            <param name="hash">The hash algorithm to use.</param>
            <exception cref="T:System.ArgumentNullException">One of the parameters is a null reference.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.Encrypt(System.Byte[])">
            <summary>
            Encrypts a given byte array.
            </summary>
            <param name="input">The array of bytes to encrypt.</param>
            <returns>A string representation of the encrypted data.</returns>
            <exception cref="T:System.ArgumentNullException"><i>input</i> is a null reference.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.Encrypt(System.String)">
            <summary>
            Encrypts a given string.
            </summary>
            <param name="input">The string to encrypt.</param>
            <returns>A string representation of the encrypted data.</returns>
            <remarks>The default encoding to convert the input string to an array of bytes is UTF-8.</remarks>
            <exception cref="T:System.ArgumentNullException"><i>input</i> is a null reference.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.Encrypt(System.String,System.Text.Encoding)">
            <summary>
            Encrypts a given string.
            </summary>
            <param name="input">The string to encrypt.</param>
            <param name="encoding">The encoding to use to convert the string to an array of bytes.</param>
            <returns>A string representation of the encrypted data.</returns>
            <exception cref="T:System.ArgumentNullException"><i>input</i> or <i>encoding</i> is a null reference.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.Decrypt(System.String)">
            <summary>
            Decrypts a given string.
            </summary>
            <param name="input">The string to decrypt.</param>
            <returns>An array of bytes, containing the unencrypted data.</returns>
            <exception cref="T:System.ArgumentNullException"><i>input</i> is a null reference.</exception>
            <exception cref="T:System.FormatException"><i>input</i> is an invalid Base64 string.</exception>
            <exception cref="T:System.ArgumentException">The length of <i>input</i> is invalid.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs during the decryption or integrity verification.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.DecryptString(System.String,System.Text.Encoding)">
            <summary>
            Decrypts a given string.
            </summary>
            <param name="input">The string to decrypt.</param>
            <param name="encoding">The encoding to use to convert the string to an array of bytes.</param>
            <returns>A string containing the unencrypted data.</returns>
            <exception cref="T:System.ArgumentNullException"><i>input</i> or <i>encoding</i> is a null reference.</exception>
            <exception cref="T:System.FormatException"><i>input</i> is an invalid Base64 string.</exception>
            <exception cref="T:System.ArgumentException">The length of <i>input</i> is invalid.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs during the decryption or integrity verification.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.StringEncryption.DecryptString(System.String)">
            <summary>
            Decrypts a given string.
            </summary>
            <param name="input">The string to decrypt.</param>
            <returns>A string containing the unencrypted data.</returns>
            <remarks>The default encoding to convert the input string to an array of bytes is UTF-8.</remarks>
            <exception cref="T:System.ArgumentNullException"><i>input</i> is a null reference.</exception>
            <exception cref="T:System.FormatException"><i>input</i> is an invalid Base64 string.</exception>
            <exception cref="T:System.ArgumentException">The length of <i>input</i> is invalid.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs during the decryption or integrity verification.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.StringEncryption.Key">
            <summary>
            Gets or sets the key of the bulk cipher algorithm.
            </summary>
            <value>An array of bytes that contains the key of the bulk cipher algorithm.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.StringEncryption.IV">
            <summary>
            Gets or sets the initialization vector of the bulk cipher algorithm.
            </summary>
            <value>An array of bytes that contains the initialization vector of the bulk cipher algorithm.</value>
        </member>
        <member name="T:LLCryptoLib.Hash.SHA224">
            <summary>Computes the SHA224 hash for the input data using the managed library.</summary>
        </member>
        <member name="T:LLCryptoLib.Hash.BlockHashAlgorithm">
            <summary>Represents the abstract class from which all implementations of the Classless.Hasher.BlockHashAlgorithm inherit.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.BlockHashAlgorithm.#ctor(System.Int32)">
            <summary>Initializes a new instance of the BlockHashAlgorithm class.</summary>
            <param name="blockSize">The size in bytes of an individual block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.BlockHashAlgorithm.Initialize">
            <summary>Initializes the algorithm.</summary>
            <remarks>If this function is overriden in a derived class, the new function should call back to
            this function or you could risk garbage being carried over from one calculation to the next.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.BlockHashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Performs the hash algorithm on the data provided.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.BlockHashAlgorithm.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.BlockHashAlgorithm.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.BlockHashAlgorithm.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code in bytes</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.BlockHashAlgorithm.BlockSize">
            <summary>The size in bytes of an individual block.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.BlockHashAlgorithm.BufferCount">
            <summary>The number of bytes currently in the buffer waiting to be processed.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.BlockHashAlgorithm.Count">
            <summary>The number of bytes that have been processed.</summary>
            <remarks>This number does NOT include the bytes that are waiting in the buffer.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA224.#ctor">
            <summary>Initializes a new instance of the SHA224 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA224.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA224.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA224.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.RIPEMD128">
            <summary>Computes the RIPEMD128 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD128.#ctor">
            <summary>Initializes a new instance of the RIPEMD128 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD128.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD128.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD128.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes to process.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.Hash">
            <summary>
            Base Hash class. Wraps all hashing functions.
            </summary>
            <example>
            <code>
            IHash hashObject = new Hash();
            hashObject.SetAlgorithm(AvailableHash.MD5);
            Console.WriteLine("MD5 hash: {0}", hashObject.ComputeHashFileStyle(fileToHash.FullName, HexStyle.UNIX));
            </code>
            </example>
        </member>
        <member name="T:LLCryptoLib.Hash.IHash">
            <summary>
            Base interface for all Hash objects.
            </summary>
            <example>
            <code>
            IHash hashObject = new Hash();
            hashObject.SetAlgorithm(AvailableHash.MD5);
            Console.WriteLine("MD5 hash: {0}", hashObject.ComputeHashFileStyle(fileToHash.FullName, HexStyle.UNIX));
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.SetAlgorithmInt(System.Int32)">
            <summary>
            Set Hashing Function algorithm. It's not a property following COM standards.
            </summary>
            <param name="algoId">Algorithm int ID identifier:
            		FAKE = 0, 
                    ADLER32 = 12,
                    CRC32 = 6,
                    FCS16 = 19,
                    FCS32 = 20,
                    GOST = 22,
                    MD2 = 7,
                    MD4 = 8,
                    MD5 = 5,
                    SHA1 = 2,
                    SHA224 = 21,
                    SHA256 = 3,
                    SHA384 = 1,
                    SHA512 = 4,
                    TIGER = 10,
                    RIPEMD160 = 9,
                    HAVAL128 = 13,
                    HAVAL160 = 14,
                    HAVAL192 = 15,
                    HAVAL224 = 16,
                    HAVAL256 = 17,
                    HMACSHA1 = 11,
                    WHIRLPOOL = 18
            </param>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.SetAlgorithm(LLCryptoLib.Hash.AvailableHash)">
            <summary>
            Set Hashing Function algorithm. It's not a property following COM standards.
            </summary>
            <param name="sh">Selected Hash Algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.SetAlgorithmAlgo(LLCryptoLib.Hash.SupportedHashAlgo)">
            <summary>
            Set Hashing Function algorithm. It's not a property following COM standards.
            </summary>
            <param name="sha">Selected Hash Algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.SetAlgorithmBytes(LLCryptoLib.Hash.AvailableHash,System.Byte[])">
            <summary>
            Set hashing algorithm - keyed hash algorithm
            <see cref="T:LLCryptoLib.Hash.SupportedHashAlgo"/>
            </summary>
            <param name="ha">Supported Algorithms</param>
            <param name="key">Vigenere for keyed hash algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHash(System.String)">
            <summary>
            Compute hash function of a text string
            </summary>
            <param name="message">Text string</param>
            <returns>Hash as a sequence of hexadecimal characters</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashEx(System.String,System.Char)">
            <summary>
            Compute Hash of given string
            </summary>
            <param name="message">Message to compute the hash for</param>
            <param name="divide">Char to divide hexes.</param>
            <returns>Hash string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashStyle(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Compute Hash of given string
            </summary>
            <param name="message">Message to compute the hash for</param>
            <param name="style">Style of displaying hex numbers</param>
            <returns>Hash string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashFromBytes(System.Byte[])">
            <summary>
            Computes the hash from a set of bytes and returns it as a hexadecimal string.
            </summary>
            <param name="contents">The contents as a set of bytes.</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashFromBytesStyle(System.Byte[],LLCryptoLib.HexStyle)">
            <summary>
            Computes the hash from a set of bytes and returns it as a hexadecimal string.
            </summary>
            <param name="contents">The contents as a set of bytes.</param>
            <param name="style">The hexadecimal style.</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashFile(System.String)">
            <summary>
            Compute hash function of a file
            </summary>
            <param name="filePath">File to get the hash for</param>
            <returns>Hash as a sequence of hexadecimale characters</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashFileStyle(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Compute Hash of given file. 
            </summary>
            <param name="filePath">Absolute path to a file</param>
            <param name="style">Style of displaying hex numbers</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashFileStyleEx(System.String,LLCryptoLib.HexStyle,LLCryptoLib.CallbackEntry,System.Threading.AutoResetEvent)">
            <summary>
            Compute Hash of given file. 
            </summary>
            <param name="completeFileName">Absolute path to a file</param>
            <param name="style">Style of displaying hex numbers</param>
            <param name="cbe">Delegate to be reported of operation advancement</param>
            <param name="resetDemand">A reset event to call when the operation must be cancelled</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashTextFile(System.String,System.Text.Encoding)">
            <summary>
            Compute Hash of given file. The given file must be a text file.
            </summary>
            <param name="completeFileName">Absolute path to a file</param>
            <param name="enc">Text encoding</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.ComputeHashFiles(System.IO.FileInfo[],LLCryptoLib.HexStyle,LLCryptoLib.CallbackEntry)">
            <summary>
            Compute a single hash from more than one file
            </summary>
            <param name="files">The array of files to be computed</param>
            <param name="style">A style for the Hash code in output</param>
            <param name="cbe">A callback delegate function for feedback purposes, ie: ProgressBar</param>
            <returns>The computed hash as a string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.CopyHashFile(System.String)">
            <summary>
            Copy hash of a file to the system clipboard
            </summary>
            <param name="filePath">File to get the hash for</param>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.CompareHashClipboard(System.String)">
            <summary>
            Compare the hash of  given file with the one in the clipboard.
            </summary>
            <param name="filePath">File to get the hash for</param>
            <returns>True if the hash of file is the same as the one in the clipboard</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.CompareHashClipboardEx(System.String)">
            <summary>
            Compare the hash of  given file with the one in the clipboard.
            The hash in the clipboard must be in the form: FILEPATH+"::"+HASH
            </summary>
            <param name="filePath">The file path</param>
            <returns>A detailed feedback of the operation</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.CompareHash(System.String,System.String)">
            <summary>
            Compare the hash of  given file with the one given.
            </summary>
            <param name="filePath">File to get the hash for</param>
            <param name="hashToCompare">Hash string to be compared</param>
            <returns>True if the hash of file is the same as hashToCompare string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.IHash.GetLibraryPath">
            <summary>
            Get the full library path (without dll name, without ending backslash)
            </summary>
            <returns>Library path (without dll name, without ending backslash)</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.#ctor">
            <summary>
            Hash code.
            Default algortithm SHA256
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.SetAlgorithm(LLCryptoLib.Hash.AvailableHash)">
            <summary>
            Set hashing algorithm. It's not a property following COM standards.
            <see cref="T:LLCryptoLib.Hash.SupportedHashAlgo"/>
            </summary>
            <param name="sh">Hash algorithm ID</param>
            <example>
            <code>
            IHash hashObject = new Hash();
            hashObject.SetAlgorithm(AvailableHash.MD5);
            Console.WriteLine("MD5 hash: {0}", hashObject.ComputeHashFileStyle(fileToHash.FullName, HexStyle.UNIX));
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.SetAlgorithmInt(System.Int32)">
            <summary>
            Set hashing algorithm. It's not a property following COM standards.
            The int parameter is for easy COM parameters exchange
            </summary>
            <param name="algoId">
            		FAKE = 0, 
                    ADLER32 = 12,
                    CRC32 = 6,
                    FCS16 = 19,
                    FCS32 = 20,
                    GOST = 22,
                    MD2 = 7,
                    MD4 = 8,
                    MD5 = 5,
                    SHA1 = 2,
                    SHA224 = 21,
                    SHA256 = 3,
                    SHA384 = 1,
                    SHA512 = 4,
                    TIGER = 10,
                    RIPEMD160 = 9,
                    HAVAL128 = 13,
                    HAVAL160 = 14,
                    HAVAL192 = 15,
                    HAVAL224 = 16,
                    HAVAL256 = 17,
                    HMACSHA1 = 11,
                    WHIRLPOOL = 18
            </param>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.SetAlgorithmBytes(LLCryptoLib.Hash.AvailableHash,System.Byte[])">
            <summary>
            Set hashing algorithm - keyed hash algorithm
            <see cref="T:LLCryptoLib.Hash.SupportedHashAlgo"/>
            </summary>
            <param name="ha">Supported Algorithms</param>
            <param name="key">Vigenere for keyed hash algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.SetAlgorithmAlgo(LLCryptoLib.Hash.SupportedHashAlgo)">
            <summary>
            Set hashing algorithm. It's not a property following COM standards.
            <see cref="T:LLCryptoLib.Hash.SupportedHashAlgo"/>
            </summary>
            <param name="sha">Supported Hash Algorithm object</param>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHash(System.String)">
            <summary>
            Compute Hash of given string
            </summary>
            <param name="message">Message to compute the hash for</param>
            <returns>Hash string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashStyle(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Compute Hash of given string
            </summary>
            <param name="message">Message to compute the hash for</param>
            <param name="style">Style of displaying hex numbers</param>
            <returns>Hash string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashEx(System.String,System.Char)">
            <summary>
            Compute Hash of given string
            </summary>
            <param name="message">Message to compute the hash for</param>
            <param name="divide">Char to divide hexes.</param>
            <returns>Hash string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashFile(System.String)">
            <summary>
            Compute Hash of given file. 
            </summary>
            <param name="filePath">Absolute path to file</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashFromBytes(System.Byte[])">
            <summary>
            Computes the hash from a set of bytes and returns it as a hexadecimal string.
            </summary>
            <param name="contents">The contents as a set of bytes.</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashFromBytesStyle(System.Byte[],LLCryptoLib.HexStyle)">
            <summary>
            Computes the hash from a set of bytes and returns it as a hexadecimal string.
            </summary>
            <param name="contents">The contents as a set of bytes.</param>
            <param name="style">The hexadecimal style.</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashFileStyle(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Compute Hash of given file. 
            </summary>
            <param name="filePath">Absolute path to file</param>
            <param name="style">Style of displaying hex numbers</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashFileStyleEx(System.String,LLCryptoLib.HexStyle,LLCryptoLib.CallbackEntry,System.Threading.AutoResetEvent)">
            <summary>
            Compute Hash of given file. 
            </summary>
            <param name="completeFileName">Absolute path to a file</param>
            <param name="style">Style of displaying hex numbers</param>
            <param name="cbe">Delegate to be reported of operation advancement</param>
            <param name="resetDemand">A reset event to call when the operation must be cancelled</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashFiles(System.IO.FileInfo[],LLCryptoLib.HexStyle,LLCryptoLib.CallbackEntry)">
            <summary>
            Compute the hash of multiple files
            </summary>
            <param name="files">Array of files</param>
            <param name="style">Style of text hash</param>
            <param name="cbe">Callback entry to call for feedback on operations</param>
            <returns>A string representing the hash code</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.ComputeHashTextFile(System.String,System.Text.Encoding)">
            <summary>
            Compute Hash of given file. The given file must be a text file.
            </summary>
            <param name="completeFileName">Absolute path to a file</param>
            <param name="enc">Text encoding</param>
            <returns>Hash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.CopyHashFile(System.String)">
            <summary>
            Copy hash of a file to the system clipboard.
            The file will be copied in the form: FILEPATH+"::"+HASH
            </summary>
            <param name="filePath">File to get the hash for</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.CompareHashClipboardEx(System.String)">
            <summary>
            Compare the hash of  given file with the one in the clipboard.
            The hash in the clipboard must be in the form: FILEPATH+"::"+HASH
            </summary>
            <param name="filePath">The file to be compared with the hash in the clipboard</param>
            <returns>A detailed feedback of the operation</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.CompareHashClipboard(System.String)">
            <summary>
            Compare the hash of  given file with the one in the clipboard.
            The hash in the clipboard must be in the form: FILEPATH+"::"+HASH
            </summary>
            <param name="filePath">File to get the hash for</param>
            <returns>null if comparison can't be made. Else a detailed comparison result string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.CompareHash(System.String,System.String)">
            <summary>
            Compare the hash of  given file with the one given.
            </summary>
            <param name="filePath">File to get the hash for</param>
            <param name="hashToCompare">Hash string to be compared</param>
            <returns>True if the hash of file is the same as hashToCompare string</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.HashStringLen(LLCryptoLib.HexStyle,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Returns the len of the hash string of an hashAlgo with the given HexStyler
            </summary>
            <param name="hashAlgo">Algorithm</param>
            <param name="hex">Style of hash text</param>
            <returns>Length of the hash string of an hashAlgo with the given HexStyler</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.GetLibraryPath">
            <summary>
            Get Library Path
            </summary>
            <returns>Library Path, without filename and without ending backslash</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.HashCode(System.String)">
            <summary>
            Compute the hash code of a given string
            </summary>
            <param name="txt">Message</param>
            <returns>Hash bytes</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.FormatTabString(System.String,System.String,System.String,System.String)">
            <summary>
            Return a formatted string such as column B (oneB and two B) result aligned.
            </summary>
            <param name="oneA">A string</param>
            <param name="oneB">A string</param>
            <param name="twoA">A string</param>
            <param name="twoB">A string</param>
            <returns>Formatted string such as column B (oneB and two B) result aligned</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Hash.Dispose">
            <summary>
            Set the Hash algorithm to null
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.Hash.ChunkSize">
            <summary>
            Step for in streaming file reading
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.Hash.Algorithm">
            <summary>
            Get hashing algorithm. It's not a property following COM standards.
            </summary>
            <returns>Hashing algorithm</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.CRCParameters">
            <summary>A class that contains the parameters necessary to initialize a CRC algorithm.</summary>
        </member>
        <member name="T:LLCryptoLib.Hash.HashAlgorithmParameters">
            <summary>An abstract class that represents the parameters necessary to initialize a hashing algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRCParameters.#ctor(System.Int32,System.Int64,System.Int64,System.Int64,System.Boolean)">
            <summary>Initializes a new instance of the CRCParamters class.</summary>
            <param name="order">The order of the CRC (e.g., how many bits).</param>
            <param name="polynomial">The polynomial to use in the calculations.</param>
            <param name="initial">The initial value of the CRC.</param>
            <param name="finalXOR">The final value to XOR with the CRC.</param>
            <param name="reflectIn">Whether or not to reflect the incoming data before calculating.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.CRCParameters.GetHashCode">
            <summary>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</summary>
            <returns>A hash code for the current Object.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.CRCParameters.GetParameters(LLCryptoLib.Hash.CRCStandard)">
            <summary>Retrieves a standard set of CRC parameters.</summary>
            <param name="standard">The name of the standard parameter set to retrieve.</param>
            <returns>The CRC Parameters for the given standard.</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.CRCParameters.Order">
            <summary>Gets or sets the order of the CRC (e.g., how many bits).</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.CRCParameters.Polynomial">
            <summary>Gets or sets the polynomial to use in the CRC calculations.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.CRCParameters.InitialValue">
            <summary>Gets or sets the initial value of the CRC.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.CRCParameters.FinalXORValue">
            <summary>Gets or sets the final value to XOR with the CRC.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.CRCParameters.ReflectInput">
            <summary>Gets or sets the value dictating whether or not to reflect the incoming data before calculating. (UART)</summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextCrypterFactory">
            <summary>
            A TextCryptFactory is a factory class for TextCrypter object.
            The user must supply an algorithm ID and some parameters and he gets
            an initialized TextCrypter object
            </summary>
            <example><code>
            
            // TextROT13 TEXT TRANSFORMATION
            TextAlgorithmParameters parms = new TextAlgorithmParameters(3);
            TextCrypter textEncrypter = TextCrypterFactory.Create(SupportedTextAlgorithms.ROT13,parms);
            string encrypted = textEncrypter.TextEncryptDecrypt(origString, true);
            Console.WriteLine("Encrypted string: " + encrypted);
            string decrypted = textEncrypter.TextEncryptDecrypt(encrypted, false);
            Console.WriteLine("Decrypted string: " + decrypted);
            Console.WriteLine(); 
            
            </code></example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCrypterFactory.Create(LLCryptoLib.Crypto.SupportedTextAlgorithms,LLCryptoLib.Crypto.TextAlgorithmParameters)">
            <summary>
            TextCrypter factory method. 
            
            For each SupportedTextAlgorithm, these parameters are taken into account:
            <list type="bullet">
            <item>TextROT13</item><description>parameters.Shift (rot13 shift)</description> 
            <item>POLYALPHABETIC</item><description>parameters.Key and parameters.Shift</description>
            <item>PLAYFAIR</item><description>No parameter neeeded. You can pass parameters=null</description>
            <item>PSEUDODES</item><description>parameters.Key and parameters.Shift</description>
            <item>DES</item><description>parameters.Key as password. KeyLen and BlockLen are turned to 8 in any case.</description>
            <item>TRIPLEDES</item><description>parameters.Key as password. KeyLen 16 or 24. BlockLen is always 8.</description>
            <item>RIJNDAEL</item><description>Allowed values for parameters.keylen is 16,24,32.Allowed values for parameters.blocklen are 16,24,32. If these values are not specified, then 16-16 is taken.</description>     
            </list>
            <see cref="T:LLCryptoLib.Crypto.TextAlgorithmParameters"/>
            </summary>
            <param name="algorithm">The SupportedTextAlgorithms ID for the algorithm to be used</param>
            <param name="parameters">A set of parameters</param>
            <returns>An initialized TextCrypter object</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException"/>
        </member>
        <member name="T:LLCryptoLib.Crypto.AsymmetricCrypter">
            <summary>
            Asymmetric Crypter class.
            This class implements RSA public key encryption. Public key means that a message encrypted 
            with a recipient's public key cannot be decrypted by anyone except the recipient possessing 
            the corresponding private key. To make such encryption, AsymmetricCrypter implements 
            RSA algorithm. Since this algorithm is relatively computationally costly in comparison with many 
            symmetric key algorithms of equivalent security, AsymmetricCrypter implements an
            hybrid asymmetric/symmetric cryptosystem for reasons of efficiency; in such a 
            cryptosystem, a shared secret key ("session key") is generated by one party and this much briefer 
            session key is then encrypted by each recipient's public key. Each recipient uses the corresponding 
            private key to decrypt the session key. The message is then encrypted with a symmetric algorithm
            ciphered with the session key. This is why the constructor of AsymmetricCrypter takes in input
            a <see cref="T:LLCryptoLib.Crypto.SupportedStreamAlgorithms"/> object, to determine the symmetric algorithm that will
            be used to encrypt the message. Instead, the random generated key is ciphered with RSA algorithm.
            This class also offers some utility methods to acquire public and private keys from certificates
            or external files in several formats, such as: CER, PEM or XML.
            </summary>
            <example>Encryption code:
            <code>
            AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
            RSA pubKey = AsymmetricCrypter.LoadKeyFromXmlFile(PUBLIC_KEY);
            // or RSA pubKey = AsymmetricCrypter.LoadPublicKeyFromCER(PUBLIC_KEY_CER);
            ac.Encrypt(new FileInfo(INPUT_FILE), new FileInfo(ENCRYPTED_FILE), pubKey);
            </code>
            </example>
            <example>Decryption code:
            <code>
            string storeName = "MyCA";
            string certificateName = "Alice";
            RSA privateKey = AsymmetricCrypter.LoadPrivateKey(StoreLocation.CurrentUser, storeName, certificateName);  
            AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
            ac.Decrypt(new FileInfo(ENCRYPTED_FILE), new FileInfo(DECRYPTED_FILE), privateKey);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.#ctor(LLCryptoLib.Crypto.SupportedStreamAlgorithms)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Crypto.AsymmetricCrypter"/> class.
            Encryption will be done by generating a "session key" that will be encrypted
            using the public key of the receiver. Then the message will be encrypted
            using <see cref="T:LLCryptoLib.Crypto.SupportedStreamAlgorithms"/> algorithm with the encrypted 
            key. 
            To decrypt the message, the receiver will decrypt the session key (pre-pended
            to the message, using her private key. Then she will use the session key in
            clear to decrypt the message using <see cref="T:LLCryptoLib.Crypto.SupportedStreamAlgorithms"/> algorithm.
            </summary>
            <param name="encryptionAlgorithm">The symmetric encryption algorithm.</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.Encrypt(System.IO.FileInfo,System.IO.FileInfo,System.Security.Cryptography.RSA)">
            <summary>
            Encrypts the specified input file and saves the encrypted bytes in the 
            specified output file. To do so, a "session key" will be 
            randomly generated and then encrypted using the publick key of the receiver. 
            The public key may be obtained by a digital certificate, using a 
            <see cref="T:LLCryptoLib.Security.Certificates.LLCertificate"/> object.
            Then the message will be encrypted then using <see cref="T:LLCryptoLib.Crypto.SupportedStreamAlgorithms"/> 
            algorithm supplied in the constructor with the encrypted key. 
            </summary>
            <param name="inputFile">The input file.</param>
            <param name="outputFile">The output file.</param>
            <param name="rsaPublicKey">The receiver public key.</param>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentException">Input file does not exist or has zero length</exception>
            <example>
            <code>
            AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
            RSA pubKey = AsymmetricCrypter.LoadKeyFromXmlFile(PUBLIC_KEY);
            // or RSA pubKey = AsymmetricCrypter.LoadPublicKeyFromCER(PUBLIC_KEY_CER);
            ac.Encrypt(new FileInfo(INPUT_FILE), new FileInfo(ENCRYPTED_FILE), pubKey);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.LoadPublicKeyFromCer(System.String)">
            <summary>
            Loads the public key from a CER certificate file.
            </summary>
            <param name="cerFile">The CER certificate file.</param>
            <returns>An RSA object containing the Public Key.</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">File Too Long</exception>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.LoadPublicKeyFromPem(System.String)">
            <summary>
            Loads the public key from a a PEM certificate file.
            </summary>
            <param name="pemFile">The PEM certificate file.</param>
            <returns>An RSA object containing the Public Key.</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">File Too Long</exception>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.LoadKeyFromXmlFile(System.Security.Cryptography.RSA,System.String)">
            <summary>
            Loads the public key (and optionally the private key) from an XML file.
            The XML file must adhere to the RSAKeyValue XML schema.
            </summary>
            <param name="rsaEncryptor">An object implementing RSA, as <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider"/>.</param>
            <param name="publicKeyFile">The public/private key file as XML file.</param>
            <returns>
            An RSA object containing the key
            </returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">Public Key format not recognized.</exception>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.KeyFromXml(System.Security.Cryptography.RSA,System.String)">
            <summary>
            Creates an RSA key or pair of keys (public or public with private) from an XML string.
            The XML string must adhere to the RSAKeyValue XML schema.
            </summary>
            <param name="rsaEncryptor">An object implementing RSA, as <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider"/>.</param>
            <param name="xmlCertificate">The public/private key file as XML string.</param>
            <returns>
            An RSA object containing the key.
            </returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">Public Key format not recognized.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.Sign(System.IO.FileInfo,System.IO.FileInfo,System.Security.Cryptography.RSA,LLCryptoLib.Hash.AvailableHash)">
            <summary>
            Signs the specified original file.
            </summary>
            <param name="originalFile">The original file.</param>
            <param name="signedFile">The signed file.</param>
            <param name="privateKey">The private key.</param>
            <param name="hash">The hash.</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.VerifySignature(System.IO.FileInfo,System.Security.Cryptography.RSA,LLCryptoLib.Hash.AvailableHash,System.Boolean)">
            <summary>
            Verifies the signature.
            </summary>
            <param name="signedFile">The signed file.</param>
            <param name="publicKey">The public key of the signer</param>
            <param name="hash">The hash.</param>
            <param name="removeSignature">if set to <c>true</c> [remove signature].</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.Decrypt(System.IO.FileInfo,System.IO.FileInfo,System.Security.Cryptography.RSA)">
            <summary>
            Decrypts the specified encrypted file in the specified output file, using the
            provided private key.
            Decryption is be done by reading an encrypted "session key" from the encrypted
            file and then decrypting using the private key of the receiver. If the session key
            is successfully decrypted, then the message will be decrypted
            using <see cref="T:LLCryptoLib.Crypto.SupportedStreamAlgorithms"/> algorithm with the decrypted session
            key. 
            </summary>
            <example>
            <code>
            string storeName = "MyCA";
            string certificateName = "Alice";
            RSA privateKey = AsymmetricCrypter.LoadPrivateKey(StoreLocation.CurrentUser, storeName, certificateName);  
            AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
            ac.Decrypt(new FileInfo(ENCRYPTED_FILE), new FileInfo(DECRYPTED_FILE), privateKey);
            </code>
            </example>
            <param name="encryptedFile">The encrypted file.</param>
            <param name="outputFile">The output file.</param>
            <param name="rsaPrivateKey">The RSA private key.</param>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentException">Input file does not exist.</exception>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.ImportPrivateKeyFromCertificate(System.String,System.String)">
            <summary>
            Imports the private key from certificate.
            </summary>
            <param name="certificatePfx">The certificate PFX.</param>
            <param name="password">The password.</param>
            <returns>The private key as an RSA object</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">This certificate contains no private key.</exception>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.LoadPrivateKey(LLCryptoLib.Security.Certificates.StoreLocation,System.String,System.String)">
            <summary>
            Loads a private key from a certificate stored in the registry.
            </summary>
            <param name="location">The store location.</param>
            <param name="storeName">Name of the store in registry.</param>
            <param name="certificateName">Subject string of the certificate.</param>
            <returns>The private key as an RSA object.</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.AsymmetricCrypter.VerifySignature(System.String,System.Security.Cryptography.RSA,System.Object,System.Boolean)">
             <summary>
            
             <remarks>Implement CHUNK READ of original file</remarks>
             </summary>
             <param name="inFile"></param>
             <param name="publicKey"></param>
             <param name="hashAlgorithm"></param>
             <param name="removeSignature"></param>
             
             <returns></returns>
        </member>
        <member name="T:LLCryptoLib.Utils.TempFile">
            <summary>
            Temp file class holds a list of temporary file.
            The convenient method "DeleteTempFiles" deletes
            every temp file created with "GetTempFileFullName"
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.TempFile.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.TempFile.Delete">
            <summary>
            Delete temporary files
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.TempFile.Dispose">
            <summary>
            Delete temporary files and dispose them
            </summary>
        </member>
        <member name="P:LLCryptoLib.Utils.TempFile.TempFiles">
            <summary>
            Number of temp files handled
            </summary>
        </member>
        <member name="P:LLCryptoLib.Utils.TempFile.TempFileName">
            <summary>
            Obtain a fresh temp file name complete of full path.
            Use "TempDir" property to get the path only.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Utils.RandomString">
            <summary>
            This class generates random strings in various formats.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.Get">
            <summary>
            Get a random string made of 10 alphanumeric characters, both uppercase and lowercase, with numbers.
            </summary>
            <returns>A random string of 10 alphanumeric characters.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.GetEx">
            <summary>
            Get a random string made of 10 alphanumeric characters, both uppercase and lowercase,
            with symbols and numbers.
            </summary>
            <returns>A random string 10 alphanumeric characters, both uppercase and lowercase, with symbols and numbers.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.Get(System.Int32)">
            <summary>
            Get a random string made of 'len' alphanumeric characters, both uppercase and lowercase, with numbers.
            </summary>
            <param name="len">The length of the random generated string.</param>
            <returns>A random string made of 'len' alphanumeric characters, both uppercase and lowercase, with numbers.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.GetEx(System.Int32)">
            <summary>
            Get a random string made of 'len' alphanumeric characters, both uppercase and lowercase,
            with symbols and numbers.
            </summary>
            <param name="len">A random string made of 'len' alphanumeric characters, both uppercase and lowercase, with numbers and symbols.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.IsInAlpha(System.Char)">
            <summary>
            Determines whether the character c between alphanumeric characters, both uppercase and lowercase,
            with numbers.
            </summary>
            <param name="c">The character to be found</param>
            <returns>
            	<c>true</c> if c in the specified character set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.IsInAlphaEx(System.Char)">
            <summary>
            Determines whether the character c between alphanumeric characters, both uppercase and lowercase,
            with numbers.
            </summary>
            <param name="c">The character to be found</param>
            <returns>
            	<c>true</c> if c in the specified character set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.Get(System.Int32,System.Boolean)">
            <summary>
            Get a random string made of 'len' alphanumeric characters, both uppercase and lowercase, with numbers.
            If 'withSpaces' then the resulting string may contain one or more spaces.
            </summary>
            <param name="len">The length of the random generated string.</param>
            <param name="withSpaces">if set to <c>true</c> the generated string will contain one or more spaces.</param>
            <returns>A random generated string.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.RandomString.GetEx(System.Int32,System.Boolean)">
            <summary>
            Get a random string made of 'len' alphanumeric characters, both uppercase and lowercase, with numbers and symbols.
            If 'withSpaces' then the resulting string may contain one or more spaces.
            </summary>
            <param name="len">The length of the random generated string.</param>
            <param name="withSpaces">if set to <c>true</c> the generated string will contain one or more spaces.</param>
            <returns>A random generated string.</returns>
        </member>
        <member name="T:LLCryptoLib.Utils.DirectoryElements">
            <summary>
            DirectoryElements contain a directory description
            with all its files and the number of Directories
            it contains
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.DirectoryElements.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:DirectoryElements"/> class.
            </summary>
            <param name="di">The starting directory</param>
        </member>
        <member name="M:LLCryptoLib.Utils.DirectoryElements.#ctor(System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:DirectoryElements"/> class.
            </summary>
            <param name="di">The starting directory</param>
            <param name="includeSubDirs">if set to <c>true</c> include sub directories.</param>
        </member>
        <member name="M:LLCryptoLib.Utils.DirectoryElements.RemoveElement(System.IO.FileInfo)">
            <summary>
            Removes a file from the current directory elements list.
            </summary>
            <param name="fileToRemove">The file to remove.</param>
            <returns>True, if the element was correctly removed.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.DirectoryElements.BuildList(System.IO.DirectoryInfo)">
            <summary>
            Build a list of all files within a folder.
            </summary>
            <param name="di">The full path of the folder.</param>
            <returns>True if the operations succeeds</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.DirectoryElements.Initialize(System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Initializes the specified di.
            </summary>
            <param name="di">The di.</param>
            <param name="includeSubDirs">if set to <c>true</c> [include sub dirs].</param>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">Invalid directory elements list.</exception>
        </member>
        <member name="M:LLCryptoLib.Utils.DirectoryElements.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents a description of the current directory <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            Ie: "Contains 1290 files and 12 subdirectories";
            </returns>
        </member>
        <member name="P:LLCryptoLib.Utils.DirectoryElements.IsWithSubDirs">
            <summary>
            Gets a value indicating whether this instance is with sub directories.
            </summary>
            <value>
            	<c>true</c> if this instance is with sub dirs; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LLCryptoLib.Utils.DirectoryElements.Directory">
            <summary>
            Initial Directory
            </summary>
            <value>The initial directory.</value>
        </member>
        <member name="P:LLCryptoLib.Utils.DirectoryElements.Files">
            <summary>
            A list of files into the directory
            </summary>
            <value>The list of files.</value>
        </member>
        <member name="P:LLCryptoLib.Utils.DirectoryElements.Subdirectories">
            <summary>
            Gets all subdirectories inside original one, without original one.
            </summary>
            <value>The subdirectories inside this directory</value>
        </member>
        <member name="P:LLCryptoLib.Utils.DirectoryElements.NrOfFiles">
            <summary>
            Number of files into the directory and all of its subdirectories
            </summary>
        </member>
        <member name="P:LLCryptoLib.Utils.DirectoryElements.NrOfSubdirectories">
            <summary>
            Number of subdirectories
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredSimple">
            <summary>
            Rewrites file area one time with 0x00 byte
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredBase">
            <summary>
            Base class for shred methods
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.IShredMethod">
            <summary>
            IShredMethod.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.IShredMethod.GetSequence">
            <summary>
            Sequence of bytes to be written
            </summary>
            <returns>The sequence of bytes of this shredding method</returns>
        </member>
        <member name="P:LLCryptoLib.Shred.IShredMethod.Name">
            <summary>
            Shredding method Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.IShredMethod.Passes">
            <summary>
            Number of passes
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.IShredMethod.Id">
            <summary>
            Available Shred Enum
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.IShredMethod.Description">
            <summary>
            Detailed description
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.ShredBase.passes">
            <summary>
            Shred method passes. IE: Complex method has 3 passes.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.ShredBase.bitSequence">
            <summary>
            Shred method bit sequence
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredBase.GetSequence">
            <summary>
            Returns the DOD byte sequence: 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xF6
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredBase.ToString">
            <summary>
            Returns the method description string.
            </summary>
            <returns>Returns the method description string, ie:"DoD 5220-22M"</returns>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredBase.Name">
            <summary>
            Shredding method Name
            </summary>
            <value></value>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredBase.Id">
            <summary>
            Shredding method Available Shred Enum
            </summary>
            <value></value>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredBase.Description">
            <summary>
            Shredding method Detailed description
            </summary>
            <value></value>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredBase.Passes">
            <summary>
            Returns method passes
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredSimple.#ctor">
            <summary>
            ShredSimple constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredSimple.Name">
            <summary>
            Shred Method Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredSimple.Id">
            <summary>
            Shred Enum ID
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredSimple.Description">
            <summary>
            Return "Overwrite the file area with a series of 0 (0x00) bits"
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredHmgEnh">
            <summary>
            HMG Infosec Standard 5 Enhanced shred method.
            This shred method overwrites the file area with 0's, 1's and finally a random byte.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredHmgEnh.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Shred.ShredHmgEnh"/> class.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredHmgEnh.Name">
            <summary>
            Shredding method Name
            </summary>
            <value></value>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredHmgEnh.Id">
            <summary>
            Shredding method Available Shred Enum
            </summary>
            <value></value>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredHmgEnh.Description">
            <summary>
            Shredding method Detailed description
            </summary>
            <value></value>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateChain">
            <summary>
            Defines a chain of certificates.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.#ctor(LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/> instance from a <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/>.
            </summary>
            <param name="cert">The certificate for which a chain is being built.</param>
            <remarks><paramref name="cert"/> will always be the end certificate.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="cert"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while building the certificate chain.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.#ctor(LLCryptoLib.Security.Certificates.Certificate,LLCryptoLib.Security.Certificates.CertificateStore)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/> instance from a <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/>.
            </summary>
            <param name="cert">The certificate for which a chain is being built.</param>
            <param name="additional">Any additional store to be searched for supporting certificates and CTLs.</param>
            <remarks><paramref name="cert"/> will always be the end certificate.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="cert"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while building the certificate chain.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.#ctor(LLCryptoLib.Security.Certificates.Certificate,LLCryptoLib.Security.Certificates.CertificateStore,LLCryptoLib.Security.Certificates.CertificateChainOptions)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/> instance from a <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/>.
            </summary>
            <param name="cert">The certificate for which a chain is being built.</param>
            <param name="additional">Any additional store to be searched for supporting certificates and CTLs.</param>
            <param name="options">Additional certificate chain options.</param>
            <remarks><paramref name="cert"/> will always be the end certificate.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="cert"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while building the certificate chain.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.Finalize">
            <summary>
            Disposes of the certificate chain.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.GetCertificates">
            <summary>
            Returns the list of certificates in this <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/>.
            </summary>
            <returns>An array of <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/> instances.</returns>
            <remarks>
            The certificate with index 0 is the end certificate in the chain, the certificate with the highest index is the root certificate [if it can be found].
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.VerifyChain(System.String,LLCryptoLib.Security.Certificates.AuthType)">
            <summary>
            Verifies the end <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/> according to the SSL policy rules.
            </summary>
            <param name="server">The server that returned the certificate -or- a null reference if the certificate is a client certificate.</param>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.AuthType"/> values.</param>
            <returns>One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStatus"/> values.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while verifying the certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.VerifyChain(System.String,LLCryptoLib.Security.Certificates.AuthType,LLCryptoLib.Security.Certificates.VerificationFlags)">
            <summary>
            Verifies the end <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/> according to the SSL policy rules.
            </summary>
            <param name="server">The server that returned the certificate -or- a null reference if the certificate is a client certificate.</param>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.AuthType"/> values.</param>
            <param name="flags">One or more of the <see cref="T:LLCryptoLib.Security.Certificates.VerificationFlags"/> values. VerificationFlags values can be combined with the OR operator.</param>
            <returns>One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStatus"/> values.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while verifying the certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.VerifyChain(System.String,LLCryptoLib.Security.Certificates.AuthType,LLCryptoLib.Security.Certificates.VerificationFlags,System.Byte[])">
            <summary>
            Verifies the end <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/> according to the SSL policy rules.
            </summary>
            <param name="server">The server that returned the certificate -or- a null reference if the certificate is a client certificate.</param>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.AuthType"/> values.</param>
            <param name="flags">One or more of the <see cref="T:LLCryptoLib.Security.Certificates.VerificationFlags"/> values. VerificationFlags values can be combined with the OR operator.</param>
            <param name="crl">An optional CRL to check. This parameter can be null (<b>Nothing</b> in Visual Basic).</param>
            <returns>One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStatus"/> values.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while verifying the certificate.</exception>
            <remarks>Only the leaf certificate is checked against the CRL.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.BeginVerifyChain(System.String,LLCryptoLib.Security.Certificates.AuthType,LLCryptoLib.Security.Certificates.VerificationFlags,System.AsyncCallback,System.Object)">
            <summary>
            Begins verification of the end <see cref="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate"/> according to the SSL policy rules.
            </summary>
            <param name="server">The server that returned the certificate -or- a null reference if the certificate is a client certificate.</param>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.AuthType"/> values.</param>
            <param name="flags">One or more of the <see cref="T:LLCryptoLib.Security.Certificates.VerificationFlags"/> values. VerificationFlags values can be combined with the OR operator.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="asyncState">An object that contains state information for this request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous connection.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while queuing the verification request.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.EndVerifyChain(System.IAsyncResult)">
            <summary>
            Ends a pending asynchronous certificate verification request.
            </summary>
            <param name="ar">Stores state information for this asynchronous operation as well as any user-defined data.</param>
            <returns>One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStatus"/> values.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="ar"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="ar"/> parameter was not returned by a call to the <see cref="M:LLCryptoLib.Security.Certificates.CertificateChain.BeginVerifyChain(System.String,LLCryptoLib.Security.Certificates.AuthType,LLCryptoLib.Security.Certificates.VerificationFlags,System.AsyncCallback,System.Object)"/> method.</exception>
            <exception cref="T:System.InvalidOperationException"><b>EndVerifyChain</b> was previously called for the asynchronous chain verification.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while verifying the certificate chain.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateChain.StartVerification(System.Object)">
            <summary>
            Verifies a certificate chain and calls a delegate when finished.
            </summary>
            <param name="state">Stores state information for this asynchronous operation as well as any user-defined data.</param>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChain.m_Handle">
            <summary>
            The handle of the certificate chain.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChain.m_Certificate">
            <summary>
            The end certificate that was used to build the chain.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateChain.Certificate">
            <summary>
            Returns the certificate for which this chain was built.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.Whirlpool">
            <summary>Computes the Whirlpool hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Whirlpool.#ctor">
            <summary>Initializes a new instance of the Whirlpool class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Whirlpool.#cctor">
            <summary>Initialize the substitution boxes.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Whirlpool.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Whirlpool.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Whirlpool.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.SumSysV">
            <summary>Computes the SysV-style checksum for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SumSysV.#ctor">
            <summary>Initializes a new instance of the SumSysV class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SumSysV.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SumSysV.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Performs the hash algorithm on the data provided.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SumSysV.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.SHA256">
            <summary>Computes the SHA256 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA256.#ctor">
            <summary>Initializes a new instance of the SHA256 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA256.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA256.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA256.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.ElfHash">
            <summary>Computes the ElfHash hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.ElfHash.#ctor">
            <summary>Initializes a new instance of the ElfHash class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.ElfHash.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.ElfHash.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.ElfHash.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.CRC32">
            <summary>
            CRC32
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.#cctor">
            <summary>
            Initialize the cache
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.ClearCache">
            <summary>
            Clear tables cache
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.BuildCRC32Table(System.UInt32)">
            <summary>
            Builds a crc32 table given a polynomial
            </summary>
            <param name="ulPolynomial">A polynomial input</param>
            <returns>The CRC32 table as an array of integers</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.#ctor">
            <summary>
            Creates a CRC32 object using the DefaultPolynomial
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.#ctor(System.UInt32)">
            <summary>
            Creates a CRC32 object using the specified Creates a CRC32 object
            </summary>
            <param name="aPolynomial">A polynomial.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.#ctor(System.UInt32,System.Boolean)">
            <summary>
            Construct the CRC32 object
            </summary>
            <param name="aPolynomial">A polynomial.</param>
            <param name="cacheTable">if set to <c>true</c> uses cache table.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.Initialize">
            <summary>
            Initializes an implementation of HashAlgorithm.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates and continues hash calculus
            </summary>
            <param name="buffer">Buffer of file to compute hash</param>
            <param name="ibStart">Offset start</param>
            <param name="count">Count of bytes</param>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.HashFinal">
            <summary>
            Return the CRC32 hash bytes
            </summary>
            <returns>The CRC32 hash bytes</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.ComputeHash(System.IO.Stream)">
            <summary>
            Computes the hash value for the specified Stream.
            </summary>
            <param name="inputStream">The input to compute the hash code for.</param>
            <returns>The computed hash code.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.ComputeHash(System.Byte[])">
            <summary>
            Overloaded. Computes the hash value for the input data.
            </summary>
            <param name="buffer">The input to compute the hash code for.</param>
            <returns>The computed hash code.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.CRC32.ComputeHash(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overloaded. Computes the hash value for the input data.
            </summary>
            <param name="buffer">The input to compute the hash code for.</param>
            <param name="offset">The offset into the byte array from which to begin using data.</param>
            <param name="count">The number of bytes in the array to use as data.</param>
            <returns>The computed hash code.</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.CRC32.DefaultPolynomial">
            <summary>
            Returns the default polynomial (used in WinZip, Ethernet, etc)
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.CRC32.AutoCache">
            <summary>
            Gets or sets the auto-cache setting of this class.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateStoreCollection">
            <summary>
            Defines a collection of certificate stores.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateStore">
            <summary>
            Defines a certificate store.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStore.CAStore">
            <summary>Represents the predefined system certificate store "CA". This field is constant.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStore.MyStore">
            <summary>Represents the predefined system certificate store "My". This field is constant.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStore.RootStore">
            <summary>Represents the predefined system certificate store "Root". This field is constant.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStore.TrustStore">
            <summary>Represents the predefined system certificate store "Trust". This field is constant.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStore.UnTrustedStore">
            <summary>Represents the untrusted certificate store. This field is constant.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStore.SoftwarePublisherStore">
            <summary>Represents the software publisher certificate store. This field is constant.</summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.CreateFromPfxFile(System.String,System.String)">
            <summary>
            Creates a new certificate store from a PFX/P12 encoded file.
            </summary>
            <param name="file">The full path to the PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs whil reading from the specified file.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the PFX file.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.CreateFromPfxFile(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new certificate store from a PFX/P12 encoded file.
            </summary>
            <param name="file">The full path to the PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs whil reading from the specified file.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the PFX file.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.CreateFromPfxFile(System.String,System.String,System.Boolean,LLCryptoLib.Security.Certificates.KeysetLocation)">
            <summary>
            Creates a new certificate store from a PFX/P12 encoded file.
            </summary>
            <param name="file">The full path to the PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <param name="location">One of the <see cref="T:LLCryptoLib.Security.Certificates.KeysetLocation"/> values.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs whil reading from the specified file.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the PFX file.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.CreateFromPfxFile(System.Byte[],System.String)">
            <summary>
            Creates a new certificate store from a PFX/P12 encoded file.
            </summary>
            <param name="file">The contents of a PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the PFX file.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.CreateFromPfxFile(System.Byte[],System.String,System.Boolean)">
            <summary>
            Creates a new certificate store from a PFX/P12 encoded file.
            </summary>
            <param name="file">The contents of a PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the PFX file.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.CreateFromPfxFile(System.Byte[],System.String,System.Boolean,LLCryptoLib.Security.Certificates.KeysetLocation)">
            <summary>
            Creates a new certificate store from a PFX/P12 encoded file.
            </summary>
            <param name="file">The contents of a PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <param name="location">One of the <see cref="T:LLCryptoLib.Security.Certificates.KeysetLocation"/> values.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the PFX file.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.GetFileContents(System.String)">
            <summary>
            Returns the contents of a file.
            </summary>
            <param name="file">The file to read from.</param>
            <returns>A byte array with the contents of the specified file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs while reading from the specified file.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.CreateFromCerFile(System.String)">
            <summary>
            Creates a new certificate store from a certificate file.
            </summary>
            <param name="file">The certificate file.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the certificate.</exception>
            <remarks>The provider opens the file and first attempts to read the file as a serialized store, then as a PKCS #7 signed message, and finally as a single encoded certificate.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor(LLCryptoLib.Security.Certificates.CertificateStore)">
            <summary>
            Duplicates an exisiting <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>.
            </summary>
            <param name="store">The store to duplicate.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="store"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor(System.IntPtr)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> from a given handle.
            </summary>
            <param name="handle">The handle from which to initialize the CertificateStore from.</param>
            <remarks>The handle will not be duplicated; when this CertificateStore instance is garbage collected, the handle will be freed.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> from a given handle.
            </summary>
            <param name="handle">The handle from which to initialize the CertificateStore from.</param>
            <param name="duplicate"><b>true</b> if the handle should be duplicated, <b>false</b> otherwise.</param>
            <exception cref="T:System.ArgumentException"><paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> from a given store name.
            </summary>
            <param name="store">The name of the system store to open.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="store"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while opening the specified store.</exception>
            <remarks>
            <p>If the system store name provided in this parameter is not the name of an existing system store, a new system store will be created and used.</p>
            <p>Some example system stores are listed in the following table. 
            <list type="table">
            	<listheader>
            		<term>Predefined system store name</term>
            		<description>Meaning</description>
            	</listheader>
            	<item>
            		<term>"CA"</term>
            		<description>Certification authority certificates.</description>
            	</item>
            	<item>
            		<term>"MY"</term>
            		<description>A certificate store holding "My" certificates with their associated private keys.</description>
            	</item>
            	<item>
            		<term>"ROOT"</term>
            		<description>Root certificates.</description>
            	</item>
            	<item>
            		<term>"SPC"</term>
            		<description>Software publisher certificates.</description>
            	</item>
            </list></p>
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor(LLCryptoLib.Security.Certificates.StoreLocation,System.String)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> from a given store name and a given store location.
            </summary>
            <param name="location">The location of the store.</param>
            <param name="store">The name of the store to open.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="store"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while opening the specified store.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor">
            <summary>
            Initializes a new temporary <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> in memory.
            </summary>
            <remarks>If the store is closed, all the data in the store is lost.</remarks>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while creating the store.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor(System.Collections.IEnumerable)">
            <summary>
            Initializes a new temporary <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> in memory and adds the specified certificates to it.
            </summary>
            <param name="certs">A set of certificates.</param>
            <remarks>If the store is closed, all the data in the store is lost.</remarks>
            <exception cref="T:System.InvalidCastException"><i>certs</i> contains at least one object that is not of type <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/>.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.#ctor(System.Byte[],LLCryptoLib.Security.Certificates.CertificateStoreType)">
            <summary>
            Opens a serialized certificate store or a certificate store with signed PKCS7 messages.
            </summary>
            <param name="buffer">The bytes of the store to open.</param>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreType"/> values.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while opening the store.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.InitStore(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> from a given handle.
            </summary>
            <param name="handle">The handle from which to initialize the CertificateStore from.</param>
            <param name="duplicate"><b>true</b> if the handle should be duplicated, <b>false</b> otherwise.</param>
            <exception cref="T:System.ArgumentException"><paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificate">
            <summary>
            Returns the first certificate from the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>.
            </summary>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> from the store.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificate(LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Returns a certificate from the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>.
            </summary>
            <param name="previous">The previous certificate.</param>
            <returns>The <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> that comes after <paramref name="previous"/> -or- a null reference (<b>Nothing in Visual Basic</b>) if there is no certificate after <paremref name="previous"/>.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateByUsage(System.String[])">
            <summary>
            Finds a certificate having an enhanced key extension that matches one of the <paramref name="keyUsage"/> members.
            </summary>
            <param name="keyUsage">The list of enhanced key usages to search for.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> that has at least one of the specified key usages -or- a null reference (<b>Nothing in Visual Basic</b>) if no valid certificate could be found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="keyUsage"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="keyUsage"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateByUsage(System.String[],LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Finds a certificate having an enhanced key extension that matches one of the <paramref name="keyUsage"/> members.
            </summary>
            <param name="keyUsage">The list of enhanced key usages to search for.</param>
            <param name="previous">The previous certificate.</param>
            <returns>The <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> that comes after <paramref name="previous"/> and that has at least one of the specified key usages -or- a null reference (<b>Nothing in Visual Basic</b>) if no other valid certificate could be found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="keyUsage"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="keyUsage"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateByHash(System.Byte[])">
            <summary>
            Finds a certificate with a matching hash.
            </summary>
            <param name="hash">The hash to search for.</param>
            <returns>The <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> with the matching default hash -or- a null reference (<b>Nothing</b> in Visual Basic) if no certificate with that hash could be found in the store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="hash"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateByHash(System.Byte[],LLCryptoLib.Security.Certificates.HashType)">
            <summary>
            Finds a certificate with a matching hash.
            </summary>
            <param name="hash">The hash to search for.</param>
            <param name="hashType">One of the HashType values.</param>
            <returns>The <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> with the matching hash -or- a null reference (<b>Nothing</b> in Visual Basic) if no certificate with that hash could be found in the store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="hash"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateByKeyIdentifier(System.Byte[])">
            <summary>
            Finds a certificate with a matching key identifier.
            </summary>
            <param name="keyID">The key identifier to search for.</param>
            <returns>The <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> with the matching key identifier -or- a null reference (<b>Nothing</b> in Visual Basic) if no matching certificate could be found in the store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="keyID"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="keyID"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateBySubjectName(System.String)">
            <summary>
            Finds a certificate with a matching subject name.
            </summary>
            <param name="name">The X500 string to search for.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> with a matching subject name -or- a null reference (<b>Nothing</b> in Visual Basic) if no matching certificate could be found in the store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateBySubjectName(System.String,LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Finds a certificate with a matching subject name.
            </summary>
            <param name="name">The X500 string to search for.</param>
            <param name="previous">The previous certificate.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> with a matching subject name -or- a null reference (<b>Nothing</b> in Visual Basic) if no matching certificate could be found in the store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is invalid.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while encoding the specified string.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateBySubjectString(System.String)">
            <summary>
            Finds a certificate with a subject that contains a specified string.
            </summary>
            <param name="subject">The string to search for.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> with a matching subject string -or- a null reference (<b>Nothing</b> in Visual Basic) if no matching certificate could be found in the store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="subject"/> is invalid.</exception>
            <remarks>The string matching algorithm used is case-insensitive.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.FindCertificateBySubjectString(System.String,LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Finds a certificate with a subject that contains a specified string.
            </summary>
            <param name="subject">The string to search for.</param>
            <param name="previous">The previous certificate.</param>
            <returns>A <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> with a matching subject string -or- a null reference (<b>Nothing</b> in Visual Basic) if no matching certificate could be found in the store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="subject"/> is invalid.</exception>
            <remarks>The string matching algorithm used is case-insensitive.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.EnumCertificates">
            <summary>
            Enumerates all the certificates in the store.
            </summary>
            <returns>An array of <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> instances.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.EnumCertificates(System.String[])">
            <summary>
            Enumerates all the certificates in the store.
            </summary>
            <param name="keyUsage">The list of enhanced key usages to search for.</param>
            <returns>An array of <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> instances.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="keyUsage"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="keyUsage"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.ToPfxFile(System.String,System.String,System.Boolean)">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> as a PFX encoded file.
            </summary>
            <param name="filename">The filename of the new PFX file.</param>
            <param name="password">The password to use when encrypting the private keys.</param>
            <param name="exportPrivateKeys"><b>true</b> if the private keys should be exported [if possible], <b>false</b> otherwise.</param>
            <remarks>If the specified file already exists, the method will throw an exception.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="filename"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while exporting the certificate store.</exception>
            <exception cref="T:System.IO.IOException">An error occurs while writing the data to the file.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.ToPfxBuffer(System.String,System.Boolean)">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> as a PFX encoded file.
            </summary>
            <param name="password">The password to use when encrypting the private keys.</param>
            <param name="exportPrivateKeys"><b>true</b> if the private keys should be exported [if possible], <b>false</b> otherwise.</param>
            <returns>An array of bytes that represents the PFX encoded store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while exporting the certificate store.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.GetPfxBuffer(System.String,System.Boolean)">
            <summary>
            Returns the byte representation of the PFX encoded store.
            </summary>
            <param name="password">The password to use when encrypting the private keys.</param>
            <param name="exportPrivateKeys"><b>true</b> if the private keys should be exported [if possible], <b>false</b> otherwise.</param>
            <returns>An array of bytes that represents the PFX encoded store.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.ToCerFile(System.String,LLCryptoLib.Security.Certificates.CertificateStoreType)">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> in a file.
            </summary>
            <param name="filename">The filename of the serialized store.</param>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreType"/> values.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="filename"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while saving the store to the memory buffer.</exception>
            <exception cref="T:System.IO.IOException">An error occurs while writing the data.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.ToCerBuffer(LLCryptoLib.Security.Certificates.CertificateStoreType)">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> in a buffer.
            </summary>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreType"/> values.</param>
            <returns>An array of bytes that represents the encoded store.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while saving the store to the memory buffer.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.GetCerBuffer(LLCryptoLib.Security.Certificates.CertificateStoreType)">
            <summary>
            Returns the byte representation of the serialized store.
            </summary>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreType"/> values.</param>
            <returns>An array of bytes that represents the encoded store.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while saving the store to the memory buffer.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.SaveToFile(System.Byte[],System.String)">
            <summary>
            Writes a buffer with data to a file.
            </summary>
            <param name="buffer">The buffer to write.</param>
            <param name="filename">The filename to write the data to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> or <paramref name="filename"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs while writing the data.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.AddCertificate(LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Adds a <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> to the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>.
            </summary>
            <param name="cert">The certificate to add to the store.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="cert"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while adding the certificate to the store.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.DeleteCertificate(LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Deletes a <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> from the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>.
            </summary>
            <param name="cert">The certificate to be deleted</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="cert"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while removing the certificate from the store.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStore.Finalize">
            <summary>
            Disposes of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStore.m_Handle">
            <summary>
            Holds the handle of the certificate store.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateStore.Handle">
            <summary>
            Gets the handle of the CertificateStore.
            </summary>
            <value>An IntPtr that represents the handle of the certificate.</value>
            <remarks>The handle returned by this property should not be closed. If the handle is closed by an external actor, the methods of the CertificateStore object may fail in undocumented ways [for instance, an Access Violation may occur].</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStoreCollection.#ctor(LLCryptoLib.Security.Certificates.CertificateStore[])">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreCollection"/> class.
            </summary>
            <param name="stores">An array of stores that should be added to the collection.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stores"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> objects in the array is a <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreCollection"/> instance. This is not allowed to avoid circular dependencies.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while adding a certificate to the collection.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStoreCollection.#ctor(LLCryptoLib.Security.Certificates.CertificateStoreCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreCollection"/> class.
            </summary>
            <param name="collection">The CertificateStoreCollection whose elements are copied to the new certificate store collection.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while adding a certificate to the collection.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStoreCollection.AddStore(LLCryptoLib.Security.Certificates.CertificateStore)">
            <summary>
            Adds a certificate store to the collection.
            </summary>
            <param name="store">An instance of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> class.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="store"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">The specified certificate store is a <see cref="T:LLCryptoLib.Security.Certificates.CertificateStoreCollection"/> instance. This is not allowed to avoid circular dependencies.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while adding the certificate to the collection.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateStoreCollection.RemoveStore(LLCryptoLib.Security.Certificates.CertificateStore)">
            <summary>
            Removes a certificate store from the collection.
            </summary>
            <param name="store">An instance of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> class.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="store"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStoreCollection.m_Stores">
            <summary>
            Holds the references to the CertificateStore instances in the collection. This is to avoid CertificateStores finalizing and destroying their handles.
            </summary>
        </member>
        <member name="T:LLCryptoLib.HexStyler">
            <summary>
            HexStyler.
            This class holds a string representation of a series of bytes[].
            The available styles are:
            <list type="bullet">
            <item>UNIX</item><description>ff12ab4d</description>
            <item>SPACE</item><description>FF 12 AB 4D</description>
            <item>CLASSIC</item><description>FF12AB4D</description>
            <item>NETSCAPE</item><description>FF:12:AB:4D</description>
            </list>
            <remarks>In v.1.2 of LLCryptoLib this class contained the Enumeration of available Hex Styles. The enumeration has been shifted to HexStyle</remarks>
            <see cref="T:LLCryptoLib.HexStyle"/>
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyler.UNIX">
            <summary>
            Unix style: ff12ab4d
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyler.SPACE">
            <summary>
            Space style: FF 12 AB 4D
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyler.CLASSIC">
            <summary>
            Classic style: FF12AB4D
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyler.NETSCAPE">
            <summary>
            Netscape(TM) style: FF:12:AB:4D
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyler.MODERN">
            <summary>
            Netscape(TM) style: FF:12:AB:4D
            </summary>
        </member>
        <member name="M:LLCryptoLib.HexStyler.#ctor(LLCryptoLib.HexStyle)">
            <summary>
            Constructor
            </summary>
            <param name="i">Identifier of style.
            </param>
        </member>
        <member name="M:LLCryptoLib.HexStyler.AvailableStyles">
            <summary>
            Availables hex styles
            </summary>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.HexStyler.Recognize(System.String)">
            <summary>
            Return the hex style format of an hexstring
            </summary>
            <param name="hexstring">an existing string with hexadecimal numbers</param>
            <returns>The recognized HexStyle, or HexStyle.UNKNOWN if not recognized</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.HexStyler.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. <see cref="M:System.Object.GetHashCode"></see> is suitable for use in hashing algorithms and data structures like a hash table.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object">HexStyler</see>.
            </returns>
        </member>
        <member name="M:LLCryptoLib.HexStyler.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
        </member>
        <member name="M:LLCryptoLib.HexStyler.op_Equality(LLCryptoLib.HexStyler,LLCryptoLib.HexStyler)">
            <summary>
            Operator == for the HexStyler object
            </summary>
            <param name="lhs">An HexStyler object</param>
            <param name="rhs">An HexStyler object</param>
            <returns>true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.HexStyler.op_Inequality(LLCryptoLib.HexStyler,LLCryptoLib.HexStyler)">
            <summary>
            If this style is NOT equal to obj
            </summary>
            <param name="lhs">An HexStyler object</param>
            <param name="rhs">An HexStyler object</param>
            <returns>false if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, true</returns>
        </member>
        <member name="M:LLCryptoLib.HexStyler.Transform(LLCryptoLib.HexStyle,System.String)">
            <summary>
            Transform an HexStyler style to another style
            </summary>
            <param name="toStyle">The new style to apply to 'styledText'</param>
            <param name="styledText">The string in 'this' style form</param>
            <returns>The string transformed from this style, to style 'toStyle'</returns>
        </member>
        <member name="M:LLCryptoLib.HexStyler.ToPlain(System.String)">
            <summary>
            Transform the given string in this representation style into a string without style
            (the same to be given in input to Format method)
            </summary>
            <param name="styledText">Original string with style. The style of the string must be 'this'</param>
            <returns>The given string with style without style (in Unix style)</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.HexStyler.Format(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Given a stringbuilder of bytes values in hexadecimal format
            return a string in the wanted style.
            </summary>
            <param name="hexRepr">Is a StringBuilder containing a plain bytes representation (in the UNIX form) in lowercase or uppercase</param>
            <param name="newFormat">The wanted style</param>
            <returns>A string with the wanted style</returns>
        </member>
        <member name="M:LLCryptoLib.HexStyler.Format(System.String)">
            <summary>
            Given a stringbuilder of bytes values in hexadecimal format
            return a string in the wanted style.
            </summary>
            <param name="hexBytesRepr">Is a StringBuilder containing a plain bytes representation (in the UNIX form) in lowercase or uppercase</param>
            <returns>A string with the wanted style</returns>
        </member>
        <member name="P:LLCryptoLib.HexStyler.Style">
            <summary>
            Get/Set the style ID for this Style.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.XUM32">
            <summary>Computes the XUM32 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.XUM32.#ctor">
            <summary>Initializes a new instance of the XUMHash class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.XUM32.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.XUM32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.XUM32.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.Snefru2Standard">
            <summary>Predefined standard parameters for Snefru2 algorithms.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.Snefru2Standard.Snefru2_4_128">
            <summary>Four passes with a 128bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.Snefru2Standard.Snefru2_4_256">
            <summary>Four passes with a 256bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.Snefru2Standard.Snefru2_8_128">
            <summary>Eight passes with a 128bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.Snefru2Standard.Snefru2_8_256">
            <summary>Eight passes with a 256bit result hash.</summary>
        </member>
        <member name="T:LLCryptoLib.Hash.HAVALStandard">
            <summary>Predefined standard parameters for HAVAL algorithms.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_3_128">
            <summary>Three passes with a 128bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_3_160">
            <summary>Three passes with a 160bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_3_192">
            <summary>Three passes with a 192bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_3_224">
            <summary>Three passes with a 224bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_3_256">
            <summary>Three passes with a 256bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_4_128">
            <summary>Four passes with a 128bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_4_160">
            <summary>Four passes with a 160bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_4_192">
            <summary>Four passes with a 192bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_4_224">
            <summary>Four passes with a 224bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_4_256">
            <summary>Four passes with a 256bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_5_128">
            <summary>Five passes with a 128bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_5_160">
            <summary>Five passes with a 160bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_5_192">
            <summary>Five passes with a 192bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_5_224">
            <summary>Five passes with a 224bit result hash.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.HAVALStandard.HAVAL_5_256">
            <summary>Five passes with a 256bit result hash.</summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextROT13">
            <summary>
            Performs a TextROT13 transformation.
            In 50 Bc., one of the most simple cryptographic algorithms ever used was 
            the one called the TextROT13 cipher, that was used by Julius TextROT13 to send messages to his generals. 
            It consisted simply of switching each letter with the letter that was 3 letters further down the alphabet. 
            For example Stephen would become Vwhskhq. To decrypt the message, the receivers would simply subtract 3 letters 
            from each letter. This algorithm was later improved and called TextROT13, where the letters could be shifted 
            to any number between 1 and 25, and the number of letters shifted was the secret key.
            In this implementation, the shift may be any short number > 1.
            </summary>
            <example>ROT13 Encryption
            <code>
            // TextROT13 TEXT TRANSFORMATION
            TextAlgorithmParameters parms = new TextAlgorithmParameters(3);
            TextCrypter textEncrypter = TextCrypterFactory.Create(SupportedTextAlgorithms.ROT13,parms);
            string encrypted = textEncrypter.TextEncryptDecrypt(origString, true);
            Console.WriteLine("Encrypted string: " + encrypted);
            string decrypted = textEncrypter.TextEncryptDecrypt(encrypted, false);
            Console.WriteLine("Decrypted string: " + decrypted);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextROT13.#ctor(LLCryptoLib.Crypto.TextAlgorithmParameters)">
            <summary>
            Constructort
            </summary>
            <param name="p">Contains the shift information</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextROT13.Code(System.String)">
            <summary>
            Code the given text
            </summary>
            <param name="txt">Text to be coded</param>
            <returns>TextROT13 coded text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextROT13.Decode(System.String)">
            <summary>
            Decode the given text
            </summary>
            <param name="txt">Text to decode</param>
            <returns>Clear (decoded) text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextROT13.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="T:LLCryptoLib.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00001">
            <summary>
              Looks up a localized string similar to Nothing.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00002">
            <summary>
              Looks up a localized string similar to Just delete the file without erasing..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00003">
            <summary>
              Looks up a localized string similar to Delete only.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00004">
            <summary>
              Looks up a localized string similar to Single Overwrite.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00005">
            <summary>
              Looks up a localized string similar to Overwrite the file area with a series of 0 (0x00) bits.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00006">
            <summary>
              Looks up a localized string similar to Navso P-5329-26.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00007">
            <summary>
              Looks up a localized string similar to Three times overwrite the file area with a sequence of 0(0x00)-1(0xFF) and a random character.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00008">
            <summary>
              Looks up a localized string similar to PseudoRandom.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00009">
            <summary>
              Looks up a localized string similar to Five times overwrite the file area with a sequence of pseudorandom bits.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00010">
            <summary>
              Looks up a localized string similar to DoD 5220-22M.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00011">
            <summary>
              Looks up a localized string similar to Three iterations completely overwrite the file area six times. Each iteration makes two write-passes over the file area: the first pass inscribes ONEs (1) and the next pass inscribes ZEROes (0). After the third iteration, a seventh pass writes the government-designated code 246 across the drive (in hex 0xF6).
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00012">
            <summary>
              Looks up a localized string similar to Gutmann.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00013">
            <summary>
              Looks up a localized string similar to Overwrite the file area 36 times, following the Gutmann standard recommendations..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00014">
            <summary>
              Looks up a localized string similar to HMG IS5 Enhanced.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00015">
            <summary>
              Looks up a localized string similar to Three iterations overwrite the file area. The first one inscribes &apos;0&apos;s, the second one &apos;1&apos;s, and finally a random byte is inscribed..
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00016">
            <summary>
              Looks up a localized string similar to German VSITR.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Strings.S00017">
            <summary>
              Looks up a localized string similar to This 7 passes shred algorithm overwrites the area with 0&apos;s, 1&apos;s, 0&apos;s, 1&apos;s, 0&apos;s, 1&apos;s and finally &apos;A&apos; byte (0x41).
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.DataBlob">
            <summary>
            The DataBlob structure contains an array of bytes. 
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.CertificateInfo">
            <summary>
            The CertificateInfo structure contains a certificate's information.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.CERT_PUBLIC_KEY_INFO">
            <summary>
            The CERT_PUBLIC_KEY_INFO structure contains a public key and its algorithm.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.CertificateContext">
            <summary>
            The CertificateContext structure contains both the encoded and decoded representations of a certificate.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.TrustListUsage">
            <summary>
            The TrustListUsage structure contains an array of Object Identifiers (OIDs) for Certificate Trust List (CTL) extensions. CTL_USAGE structures are used in functions that search for CTLs for specific uses.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.CertificateExtension">
            <summary>
            The CertificateExtension structure contains the extension information for a certificate, Certificate Revocation List (CRL) or Certificate Trust List (CTL).
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.CertificateNameValue">
            <summary>
            The CertificateNameValue structure contains a relative distinguished name (RDN) attribute value. It is like the CERT_RDN_ATTR structure, except that it does not include the object identifier member that is a member of CERT_RDN_ATTR. As in CERT_RDN_ATTR, the interpretation of the Value member depends on dwValueType.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.CertificateNameInfo">
            <summary>
            The CertificateNameInfo structure contains subject or issuer names. The information is represented as an array of CERT_RDN structures.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.RelativeDistinguishedName">
            <summary>
            The RelativeDistinguishedName structure contains a relative distinguished name (RDN) consisting of an array of CERT_RDN_ATTR structures.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.RdnAttribute">
            <summary>
            The RdnAttribute structure contains a single attribute of a relative distinguished name (RDN). A whole RDN is expressed in a CERT_RDN structure that contains an array of CERT_RDN_ATTR structures.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.ChainParameters">
            <summary>
            The ChainParameters structure establishing the searching and matching criteria to be used in building a certificate chain.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.ChainPolicyStatus">
            <summary>
            The ChainPolicyStatus structure holds certificate chain status information returned by CertVerifyCertificateChainPolicy from the verification of certificate chains.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.ChainPolicyParameters">
            <summary>
            The ChainPolicyParameters structure contains information used in CertVerifyCertificateChainPolicy to establish policy criteria for the verification of certificate chains.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.SslPolicyParameters">
            <summary>
            The SslPolicyParameters structure contains extra policy options.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.CRYPT_KEY_PROV_INFO">
            <summary>
            The CRYPT_KEY_PROV_INFO structure contains fields that are passed as the arguments to CryptAcquireContext to acquire a handle to a particular key container within a particular cryptographic service provider (CSP), or to create or destroy a key container.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.PUBLIC_KEY_BLOB">
            <summary>
            Union of the PUBLICKEYSTRUC [=BLOBHEADER] and RSAPUBKEY structures 
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hexer">
            <summary>
            Utility class to transform a string or bytes sequence into a hex series.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hexer.GetNumberOfBytesInHexString(System.String)">
            <summary>
            Gets the number of bytes in input hexadecimal string. 
            </summary>
            <param name="hexInput">The hexadecimal string.</param>
            <returns>The number of bytes in hex string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hexer.IsHexDigit(System.Char)">
            <summary>
            Determines whether the specified char is a hex digit, that is
            it is between 0..9..F
            </summary>
            <param name="c">The character</param>
            <returns>
            	<c>true</c> if c is hex digit; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:LLCryptoLib.Hexer.Bytes2Text(System.Byte[])">
            <summary>
            Converts an array of bytes in the corresponding string using UTF8 encoding.
            </summary>
            <param name="ibytes">The input bytes.</param>
            <returns>The string corresponding from UTF8 byte conversion</returns>
        </member>
        <member name="M:LLCryptoLib.Hexer.Text2Bytes(System.String)">
            <summary>
            Creates a byte array from a string using UTF8 encoding.
            </summary>
            <param name="text">A string to convert to a byte array.</param>
            <returns>A byte array resulting from the conversion of the input string with UTF8 encoding</returns>
        </member>
        <member name="M:LLCryptoLib.Hexer.Hex2Bytes(System.String)">
            <summary>
            Creates a byte array from the hexadecimal string. Each two characters are combined
            to create one byte. First two hexadecimal characters become first byte in returned array.
            Non-hexadecimal characters are ignored. 
            </summary>
            <param name="hexInput">A hexadecimal string to convert to byte array</param>
            <returns>A byte array, in the same left-to-right order as the hexString</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hexer.Text2Hex(System.String)">
            <summary>
            Transform a string to hex, without dividing character between hexes
            </summary>
            <param name="text">input string</param>
            <returns>Hex version of input string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hexer.Text2Hex(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Transform a string to hex
            </summary>
            <param name="text">input string</param>
            <param name="style">hexadecimal style</param>
            <returns>Hex version of input string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hexer.Text2Int(System.String)">
            <summary>
            Transform a string to a int number summing
            the ASCII value if its characters
            </summary>
            <param name="text">input string</param>
            <returns>Integer number of the string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hexer.Hex2Text(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Transform hex series into the corresponding string
            </summary>
            <param name="hex">Hex series (ie: 2A 3B 4C FF ...)</param>
            <param name="style">Style of the given hex series</param>
            <returns>Text string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hexer.BytesToHex(System.Byte[],System.Char)">
            <summary>
            Convert a stream of bytes into a string of hexadecimal numbers
            </summary>
            <param name="inbytes">Array of bytes</param>
            <param name="divide">dividing char between hexes</param>
            <returns>String of hexadecimal values</returns>
        </member>
        <member name="M:LLCryptoLib.Hexer.BytesToHex(System.Byte[],LLCryptoLib.HexStyle)">
            <summary>
            Convert a stream of bytes into a string of hexadecimal numbers, without divisor char.
            </summary>
            <param name="inbytes">Array of bytes</param>
            <param name="style">Hexadecimal style</param>
            <returns>String of hexadecimal values</returns>
        </member>
        <member name="M:LLCryptoLib.Hexer.IsHex(System.String,LLCryptoLib.HexStyle)">
            <summary>
            Check if supplied string is a series of hexadecimal numbers.
            The check is made ONLY on the first 20 hex numbers, if these are present.
            </summary>
            <param name="text">String to verify</param>
            <param name="style">Style of the supplied text string</param>
            <returns>True, if supplied string appears to be hexadecimal</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Hexer.HexToByte(System.String)">
            <summary>
            Converts 1 or 2 character string into equivalant byte value
            </summary>
            <param name="hex">1 or 2 character string</param>
            <returns>byte</returns>
            <exception cref="T:System.ArgumentException">'hex' must be 1 or 2 characters in length.</exception>
        </member>
        <member name="T:LLCryptoLib.Hash.SHA1">
            <summary>Computes the SHA1 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA1.#ctor">
            <summary>Initializes a new instance of the SHA1 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA1.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA1.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA1.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.GHashParameters">
            <summary>A class that contains the parameters necessary to initialize a GHash algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.GHashParameters.#ctor(System.Int32)">
            <summary>Initializes a new instance of the GHashParamters class.</summary>
            <param name="shift">How many bits to shift.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.GHashParameters.GetParameters(LLCryptoLib.Hash.GHashStandard)">
            <summary>Retrieves a standard set of GHash parameters.</summary>
            <param name="standard">The name of the standard parameter set to retrieve.</param>
            <returns>The GHash Parameters for the given standard.</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.GHashParameters.Shift">
            <summary>Gets or sets the shift value.</summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextPlayfair">
            <summary>
            TextPlayfair cipher.
            The TextPlayfair is a primitiveby modern reckoningblock cipher. Any new personal computer sold 
            today can break a message encoded with it in a matter of seconds. That is, with the proper 
            software, you could use such a computer to discover the original text without knowing the cipher key. 
            Some skilled cryptogrophists and puzzle experts can even break it with nothing more than pen and paper.
            Nonetheless, it uses some principles common to modern computer block ciphers. Understanding the 
            TextPlayfair will give you a beginning insight into modern cryptographywithout all the complex mathematics 
            and number theory.
            TextPlayfair Cipher uses a 9 by 9 square, in which the letters of an agreed key word or phrase are entered 
            (suppressing duplicates), followed by the rest of the alphabet in order. I and J would usually be combined together.
            The message to be enciphered is split into pairs of letters. If the two letters in the pair are in the same row, 
            the letters to the right of each are used. If they are in the same column, the letters below each are used. 
            Otherwise, the letters at the opposite corners of the rectangle are used. 
            Special treatment is required for identical pairs of letters and a single letter left over at the end. 
            Typically an obscure letter such as X would have been inserted to pad out the message.
            </summary>
            <example>Playfair text encryption:
            <code>
            TextAlgorithmParameters parms = null;
            TextCrypter textEncrypter = TextCrypterFactory.Create(SupportedTextAlgorithms.PLAYFAIR, parms);
            string encrypted = textEncrypter.TextEncryptDecrypt(origString, true);
            Console.WriteLine("Encrypted string: " + encrypted);
            string decrypted = textEncrypter.TextEncryptDecrypt(encrypted, false);
            Console.WriteLine("Decrypted string: " + decrypted);
            Console.WriteLine();
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextPlayfair.Code(System.String)">
            <summary>
            Encoding algorithm for TextPlayfair.
            </summary>
            <param name="txt">String to encode</param>
            <returns>Encoded string</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextPlayfair.Decode(System.String)">
            <summary>
            Decoding algorithm for TextPlayfair.
            </summary>
            <param name="txt">Encoded string</param>
            <returns>Decoded string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextPlayfair.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextAlgorithmParameters">
            <summary>
            Class to share parameters between different crypto methods.
            </summary>
            <example><code>
            
                    // TextROT13 TEXT TRANSFORMATION
                   TextAlgorithmParameters parms = new TextAlgorithmParameters(3);
                   TextCrypter textEncrypter = TextCrypterFactory.Create(SupportedTextAlgorithms.ROT13,parms);
                   string encrypted = textEncrypter.TextEncryptDecrypt(origString, true);
                   Console.WriteLine("Encrypted string: " + encrypted);
                   string decrypted = textEncrypter.TextEncryptDecrypt(encrypted, false);
                   Console.WriteLine("Decrypted string: " + decrypted);
            	   Console.WriteLine(); 
            
            </code></example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithmParameters.#ctor(System.Int32)">
            <summary>
            Constructor with shift.
            </summary>
            <param name="shift">Shift for caesar method (IE: shift=3, A+shift=D)</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithmParameters.#ctor(System.String)">
            <summary>
            Constructor with key
            </summary>
            <param name="key">key-string for single key</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithmParameters.#ctor(System.Int32,System.String)">
            <summary>
            Constructor with key and shift
            </summary>
            <param name="shift">Shift</param>
            <param name="key">TextVigenere</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithmParameters.#ctor(System.Int32,System.String,System.Int16,System.Int16)">
            <summary>
            Constructor with key and shift
            </summary>
            <param name="shift">Shift</param>
            <param name="key">TextVigenere</param>
            <param name="keyBlock">Block of the key in bytes</param>
            <param name="keyBytes">Size of the key in bytes</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextAlgorithmParameters.GetShiftAt(System.Int32)">
            <summary>
            Get the shift given the position in the alphabetic sequence
            </summary>
            <param name="pos">Position in ALFABETO const string</param>
            <returns>Shift</returns>
        </member>
        <member name="P:LLCryptoLib.Crypto.TextAlgorithmParameters.KeySize">
            <summary>
            Size of the key in bytes
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.TextAlgorithmParameters.BlockSize">
            <summary>
            Size of the block in bytes
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.TextAlgorithmParameters.Shift">
            <summary>
            Get Shift
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.TextAlgorithmParameters.Key">
            <summary>
            Get TextVigenere
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider">
            <summary>
            Defines a wrapper object to access the cryptographic service provider (CSP) version of the RC4 algorithm. This class cannot be inherited.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.RC4">
            <summary>
            Represents the base class from which all implementations of the RC4 symmetric stream cipher must inherit.
            </summary>
            <remarks>
            RC4 is a trademark of RSA Data Security Inc.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4.#ctor">
            <summary>
            Initializes a new instance of the RC4 class.
            </summary>
            <remarks>
            The default keysize is 128 bits.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4.GenerateIV">
            <summary>
            This is a stub method.
            </summary>
            <remarks>Since the RC4 cipher doesn't use an Initialization Vector, this method will not do anything.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4.GenerateKey">
            <summary>
            Generates a random Key to be used for the algorithm.
            </summary>
            <remarks>Use this method to generate a random key when none is specified.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4.Create">
            <summary>
            Creates an instance of the default cryptographic object used to perform the RC4 transformation.
            </summary>
            <returns>The instance of a cryptographic object used to perform the RC4 transformation.</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while acquiring the CSP.</exception>
            <exception cref="T:System.InvalidOperationException">FIPS compliance is required, but the current implementation isn't FIPS verified.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4.Create(System.String)">
            <summary>
            Creates an instance of the specified cryptographic object used to perform the RC4 transformation.
            </summary>
            <param name="algName">The name of the specific implementation of <see cref="T:LLCryptoLib.Security.Cryptography.RC4"/> to create.</param>
            <returns>A cryptographic object.</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while acquiring the CSP.</exception>
            <exception cref="T:System.InvalidOperationException">FIPS compliance is required, but the current implementation isn't FIPS verified.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.BlockSize">
            <summary>
            Gets or sets the block size of the cryptographic operation in bits.
            </summary>
            <value>The block size of RC4 is always 8 bits.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The block size is invalid.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.FeedbackSize">
            <summary>
            Gets or sets the feedback size of the cryptographic operation in bits.
            </summary>
            <value>This property always throws a <see cref="T:System.Security.Cryptography.CryptographicException"/>.</value>
            <exception cref="T:System.NotSupportedException">This exception is always thrown.</exception>
            <remarks>RC4 doesn't use the FeedbackSize property.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.IV">
            <summary>
            Gets or sets the initialization vector (IV) for the symmetric algorithm.
            </summary>
            <value>This property always returns a byte array of length one. The value of the byte in the array is always set to zero.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An attempt is made to set the IV to an invalid instance.</exception>
            <remarks>RC4 doesn't use the IV property, however the property accepts IV's of up to one byte (RC4's <see cref="P:LLCryptoLib.Security.Cryptography.RC4.BlockSize"/>) in order to interoperate with software that has been written with the use of block ciphers in mind.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.LegalBlockSizes">
            <summary>
            Gets the block sizes that are supported by the symmetric algorithm.
            </summary>
            <value>An array containing the block sizes supported by the algorithm.</value>
            <remarks>Only a block size of one byte is supported by the RC4 algorithm.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.LegalKeySizes">
            <summary>
            Gets the key sizes that are supported by the symmetric algorithm.
            </summary>
            <value>An array containing the key sizes supported by the algorithm.</value>
            <remarks>Only key sizes that match an entry in this array are supported by the symmetric algorithm.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.Mode">
            <summary>
            Gets or sets the mode for operation of the symmetric algorithm.
            </summary>
            <value>The mode for operation of the symmetric algorithm.</value>
            <remarks>RC4 only supports the OFB cipher mode. See <see cref="T:System.Security.Cryptography.CipherMode"/> for a description of this mode.</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The cipher mode is not OFB.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.Padding">
            <summary>
            Gets or sets the padding mode used in the symmetric algorithm.
            </summary>
            <value>The padding mode used in the symmetric algorithm. This property always returns PaddingMode.None.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The padding mode is set to a padding mode other than PaddingMode.None.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4.RngCsp">
            <summary>
            Returns an <see cref="T:System.Security.Cryptography.RNGCryptoServiceProvider"/> instance.
            </summary>
            <returns>An RNGCryptoServiceProvider instance.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider"/> class.
            </summary>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while acquiring the CSP.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.GenerateIV">
            <summary>
            This is a stub method.
            </summary>
            <remarks>Since the RC4 cipher doesn't use an Initialization Vector, this method will not do anything.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.GenerateKey">
            <summary>
            Generates a random Key to be used for the algorithm.
            </summary>
            <remarks>Use this method to generate a random key when none is specified.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates a symmetric decryptor object with the specified Key.
            </summary>
            <param name="rgbKey">The secret key to be used for the symmetric algorithm. </param>
            <param name="rgbIV">Not used in RC4. It can be a null reference or a byte array with a length less than 2.</param>
            <returns>A symmetric decryptor object.</returns>
            <remarks>This method decrypts an encrypted message created using the <see cref="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])"/> overload with the same parameters.</remarks>
            <exception cref="T:System.ObjectDisposedException">The object is disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="rgbKey"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates a symmetric encryptor object with the specified Key.
            </summary>
            <param name="rgbKey">The secret key to be used for the symmetric algorithm. </param>
            <param name="rgbIV">Not used in RC4. It can be a null reference or a byte array with a length less than 2.</param>
            <returns>A symmetric encryptor object.</returns>
            <remarks>Use the <see cref="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])"/> overload with the same parameters to decrypt the result of this method.</remarks>
            <exception cref="T:System.ObjectDisposedException">The object is disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="rgbKey"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.CanUseUnmanaged(System.Int32)">
            <summary>
            Returns a boolean that indicates whether the unmanaged CSP can be used or not.
            </summary>
            <param name="keySize">The size of the required key (in bits).</param>
            <returns><b>true</b> if the unmanaged CSP can be used to encrypt and decrypt data, <b>false</b> otherwise.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.Finalize">
            <summary>
            Finalizes the RC4CryptoServiceProvider.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.BlockSize">
            <summary>
            Gets or sets the block size of the cryptographic operation in bits.
            </summary>
            <value>The block size of RC4 is always 8 bits.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The block size is invalid.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.FeedbackSize">
            <summary>
            Gets or sets the feedback size of the cryptographic operation in bits.
            </summary>
            <value>This property always throws a <see cref="T:System.Security.Cryptography.CryptographicException"/>.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">This exception is always thrown.</exception>
            <remarks>RC4 doesn't use the FeedbackSize property.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.IV">
            <summary>
            Gets or sets the initialization vector (IV) for the symmetric algorithm.
            </summary>
            <value>This property always returns a byte array of length one. The value of the byte in the array is always set to zero.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An attempt is made to set the IV to an invalid instance.</exception>
            <remarks>RC4 doesn't use the IV property, however the property accepts IV's of up to one byte (RC4's <see cref="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.BlockSize"/>) in order to interoperate with software that has been written with the use of block ciphers in mind.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.Key">
            <summary>
            Gets or sets the secret key for the symmetric algorithm.
            </summary>
            <value>The secret key to be used for the symmetric algorithm.</value>
            <exception cref="T:System.ArgumentNullException">An attempt is made to set the key to a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.KeySize">
            <summary>
            Gets or sets the size of the secret key used by the symmetric algorithm in bits.
            </summary>
            <value>The size of the secret key used by the symmetric algorithm.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The key size is not valid.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.LegalBlockSizes">
            <summary>
            Gets the block sizes that are supported by the symmetric algorithm.
            </summary>
            <value>An array containing the block sizes supported by the algorithm.</value>
            <remarks>Only a block size of one byte is supported by the RC4 algorithm.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.LegalKeySizes">
            <summary>
            Gets the key sizes that are supported by the symmetric algorithm.
            </summary>
            <value>An array containing the key sizes supported by the algorithm.</value>
            <remarks>Only key sizes that match an entry in this array are supported by the symmetric algorithm.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.Mode">
            <summary>
            Gets or sets the mode for operation of the symmetric algorithm.
            </summary>
            <value>The mode for operation of the symmetric algorithm.</value>
            <remarks>RC4 only supports the OFB cipher mode. See <see cref="T:System.Security.Cryptography.CipherMode"/> for a description of this mode.</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The cipher mode is not OFB.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4CryptoServiceProvider.Padding">
            <summary>
            Gets or sets the padding mode used in the symmetric algorithm.
            </summary>
            <value>The padding mode used in the symmetric algorithm. This property always returns PaddingMode.None.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The padding mode is set to a padding mode other than PaddingMode.None.</exception>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.Oid">
            <summary>
            OID
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Oid.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Oid"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="description">The description.</param>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Oid.Description">
            <summary>
            Gets the description.
            </summary>
            <value>The description.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Oid.OidId">
            <summary>
            Gets the oid id.
            </summary>
            <value>The oid id.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Oid.ServerAuthentication">
            <summary>
            Gets the server authentication.
            </summary>
            <value>The server authentication.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Oid.ClientAuthentication">
            <summary>
            Gets the client authentication.
            </summary>
            <value>The client authentication.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Oid.CodeSigning">
            <summary>
            Gets the code signing.
            </summary>
            <value>The code signing.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.OidContainer">
            <summary>
            An OID container class
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.OidContainer.FromString(System.String)">
            <summary>
            Froms the string.
            </summary>
            <param name="s">A string containing OID</param>
            <returns>The OID read from the string</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.OidContainer.GetUsages">
            <summary>
            Gets the usages.
            </summary>
            <returns>The usages of this OID</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.OidContainer.GetDescription(System.String)">
            <summary>
            Gets the description.
            </summary>
            <param name="oid">The oid.</param>
            <returns>The description of the OID</returns>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.Certificate">
            <summary>
            Defines a X509 v3 encoded certificate.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPfxFile(System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by opening a PFX file and retrieving the first certificate from it.
            </summary>
            <param name="file">The full path to the PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <returns>One of the certificates in the PFX file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading certificates from the specified file.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <remarks>
            Warning: this method returns the first Certificate it can find in the specified PFX file.
            Care should be taken to verify whether the correct Certificate instance is returned
            when using PFX files that contain more than one certificate.
            For more fine-grained control over which certificate is returned, use
            the CertificateStore.CreateFromPfxFile method to instantiate a CertificateStore object
            and then use the CertificateStore.FindCertificateBy*** methods.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPfxFile(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by opening a PFX file and retrieving the first certificate from it.
            </summary>
            <param name="file">The full path to the PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <returns>One of the certificates in the PFX file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading certificates from the specified file.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <remarks>
            Warning: this method returns the first Certificate it can find in the specified PFX file.
            Care should be taken to verify whether the correct Certificate instance is returned
            when using PFX files that contain more than one certificate.
            For more fine-grained control over which certificate is returned, use
            the CertificateStore.CreateFromPfxFile method to instantiate a CertificateStore object
            and then use the CertificateStore.FindCertificateBy*** methods.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPfxFile(System.String,System.String,System.Boolean,LLCryptoLib.Security.Certificates.KeysetLocation)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by opening a PFX file and retrieving the first certificate from it.
            </summary>
            <param name="file">The full path to the PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <param name="location">One of the <see cref="T:LLCryptoLib.Security.Certificates.KeysetLocation"/> values.</param>
            <returns>One of the certificates in the PFX file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading certificates from the specified file.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <remarks>
            Warning: this method returns the first Certificate it can find in the specified PFX file.
            Care should be taken to verify whether the correct Certificate instance is returned
            when using PFX files that contain more than one certificate.
            For more fine-grained control over which certificate is returned, use
            the CertificateStore.CreateFromPfxFile method to instantiate a CertificateStore object
            and then use the CertificateStore.FindCertificateBy*** methods.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPfxFile(System.Byte[],System.String)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by opening a PFX file and retrieving the first certificate from it.
            </summary>
            <param name="file">The contents of a PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <returns>One of the certificates in the PFX file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading certificates from the specified bytes.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <remarks>
            Warning: this method returns the first Certificate it can find in the specified PFX file.
            Care should be taken to verify whether the correct Certificate instance is returned
            when using PFX files that contain more than one certificate.
            For more fine-grained control over which certificate is returned, use
            the CertificateStore.CreateFromPfxFile method to instantiate a CertificateStore object
            and then use the CertificateStore.FindCertificateBy*** methods.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPfxFile(System.Byte[],System.String,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by opening a PFX file and retrieving the first certificate from it.
            </summary>
            <param name="file">The contents of a PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <returns>One of the certificates in the PFX file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading certificates from the specified bytes.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <remarks>
            Warning: this method returns the first Certificate it can find in the specified PFX file.
            Care should be taken to verify whether the correct Certificate instance is returned
            when using PFX files that contain more than one certificate.
            For more fine-grained control over which certificate is returned, use
            the CertificateStore.CreateFromPfxFile method to instantiate a CertificateStore object
            and then use the CertificateStore.FindCertificateBy*** methods.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPfxFile(System.Byte[],System.String,System.Boolean,LLCryptoLib.Security.Certificates.KeysetLocation)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by opening a PFX file and retrieving the first certificate from it.
            </summary>
            <param name="file">The contents of a PFX file.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private keys associated with the certificates should be marked as exportable, <b>false</b> otherwise.</param>
            <param name="location">One of the <see cref="T:LLCryptoLib.Security.Certificates.KeysetLocation"/> values.</param>
            <returns>One of the certificates in the PFX file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading certificates from the specified bytes.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="password"/> is invalid.</exception>
            <remarks>
            Warning: this method returns the first Certificate it can find in the specified PFX file.
            Care should be taken to verify whether the correct Certificate instance is returned
            when using PFX files that contain more than one certificate.
            For more fine-grained control over which certificate is returned, use
            the CertificateStore.CreateFromPfxFile method to instantiate a CertificateStore object
            and then use the CertificateStore.FindCertificateBy*** methods.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromCerFile(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by opening a certificate file and retrieving the first certificate from it.
            </summary>
            <param name="file">The full path to the certificate file to open.</param>
            <returns>One of the certificates in the certificate file.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading certificates from the specified file.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromCerFile(System.Byte[])">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by reading a certificate from a certificate blob.
            </summary>
            <param name="file">The contents of the certificate file.</param>
            <returns>A Certificate instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> if a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the specified certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromCerFile(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by reading a certificate from a certificate blob.
            </summary>
            <param name="file">The contents of the certificate file.</param>
            <param name="offset">The offset from which to start reading.</param>
            <param name="size">The length of the certificate.</param>
            <returns>A Certificate instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> if a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the specified certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromX509Certificate(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by duplicating an existing <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate"/> instance.
            </summary>
            <param name="certificate">The X509Certificate instance to duplicate.</param>
            <returns>A Certificate instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="certificate"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPemFile(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by reading a certificate from a PEM encoded file.
            </summary>
            <param name="filename">The path to the PEM file.</param>
            <returns>A Certificate instance.</returns>
            <remarks>This implementation only reads certificates from PEM files. It does not read the private key from the certificate file, if one is present.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="filename"/> if a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs while reading from the file.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while reading the certificate from the PEM blob.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromPemFile(System.Byte[])">
            <summary>
            Creates a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class by reading a certificate from a PEM encoded file.
            </summary>
            <param name="file">The contents of the PEM file.</param>
            <returns>A Certificate instance.</returns>
            <remarks>This implementation only reads certificates from PEM files. It does not read the private key from the certificate file, if one is present.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="file"/> if a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while reading the certificate from the PEM blob.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertString(System.String,System.String)">
            <summary>
            Extracts an encoded certificate from a PEM file.
            </summary>
            <param name="cert">The PEM encoded certificate file.</param>
            <param name="delimiter">The delimiter to search for.</param>
            <returns>The Base64 encoded certificate if successfull or a null reference otherwise.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.#ctor(LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Duplicates a given certificate.
            </summary>
            <param name="certificate">The certificate to duplicate.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="certificate"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.#ctor(System.IntPtr)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> instance from a handle.
            </summary>
            <param name="handle">The handle from which to initialize the state of the new instance.</param>
            <exception cref="T:System.ArgumentException"><paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> instance from a handle.
            </summary>
            <param name="handle">The handle from which to initialize the state of the new instance.</param>
            <param name="duplicate"><b>true</b> if the handle should be duplicated, <b>false</b> otherwise.</param>
            <exception cref="T:System.ArgumentException"><paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.InitCertificate(System.IntPtr,System.Boolean,LLCryptoLib.Security.Certificates.CertificateStore)">
            <summary>
            Initializes this <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> instance from a handle.
            </summary>
            <param name="handle">The handle from which to initialize the state of the new instance.</param>
            <param name="duplicate"><b>true</b> if the handle should be duplicated, <b>false</b> otherwise.</param>
            <param name="store">The store that owns the certificate.</param>
            <exception cref="T:System.ArgumentException"><paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertificateInfo">
            <summary>
            Returns the <see cref="T:LLCryptoLib.Security.CertificateInfo"/> structure associated with the certificate.
            </summary>
            <returns>A CertificateInfo instance.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.#ctor(System.IntPtr,LLCryptoLib.Security.Certificates.CertificateStore)">
            <summary>
            Initializes this <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> instance from a handle.
            </summary>
            <param name="handle">The handle from which to initialize the state of the new instance.</param>
            <param name="store">The <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> that contains the certificate.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.Clone">
            <summary>
            Creates a copy of this <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/>.
            </summary>
            <returns>The Certificate this method creates, cast as an object.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.Finalize">
            <summary>
            Disposes of the certificate and frees unmanaged resources.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToString">
            <summary>
            Returns a string representation of the current <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> object.
            </summary>
            <returns>A string representation of the current Certificate object.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToString(System.Boolean)">
            <summary>
            Returns a string representation of the current X509Certificate object, with extra information, if specified.
            </summary>
            <param name="verbose"><b>true</b> to produce the verbose form of the string representation; otherwise, <b>false</b>.</param>
            <returns>A string representation of the current X509Certificate object.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertHash">
            <summary>
            Returns the hash value for the X.509v3 certificate as an array of bytes.
            </summary>
            <returns>The hash value for the X.509 certificate.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the hash of the certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertHash(LLCryptoLib.Security.Certificates.HashType)">
            <summary>
            Returns the hash value for the X.509v3 certificate as an array of bytes.
            </summary>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.HashType"/> values.</param>
            <returns>The hash value for the X.509 certificate.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the hash of the certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertHashString">
            <summary>
            Returns the hash value for the X.509v3 certificate as a hexadecimal string.
            </summary>
            <returns>The hexadecimal string representation of the X.509 certificate hash value.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the hash of the certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertHashString(LLCryptoLib.Security.Certificates.HashType)">
            <summary>
            Returns the hash value for the X.509v3 certificate as a hexadecimal string.
            </summary>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.HashType"/> values.</param>
            <returns>The hexadecimal string representation of the X.509 certificate hash value.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the hash of the certificate.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.BytesToString(System.Byte[])">
            <summary>
            Converts an array of bytes to its hexadecimal string representation.
            </summary>
            <param name="buffer">The bytes to convert.</param>
            <returns>The hexadecimal representation of the byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetEffectiveDate">
            <summary>
            Returns the effective date of this X.509v3 certificate.
            </summary>
            <returns>The effective date for this X.509 certificate.</returns>
            <remarks>The effective date is the date after which the X.509 certificate is considered valid.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetExpirationDate">
            <summary>
            Returns the expiration date of this X.509v3 certificate.
            </summary>
            <returns>The expiration date for this X.509 certificate.</returns>
            <remarks>The expiration date is the date after which the X.509 certificate is no longer considered valid.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetIssuerName">
            <summary>
            Returns the name of the certification authority that issued the X.509v3 certificate.
            </summary>
            <returns>The name of the certification authority that issued the X.509 certificate.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetKeyAlgorithm">
            <summary>
            Returns the key algorithm information for this X.509v3 certificate.
            </summary>
            <returns>The key algorithm information for this X.509 certificate as a string.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetKeyAlgorithmParameters">
            <summary>
            Returns the key algorithm parameters for the X.509v3 certificate.
            </summary>
            <returns>The key algorithm parameters for the X.509 certificate as an array of bytes.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetKeyAlgorithmParametersString">
            <summary>
            Returns the key algorithm parameters for the X.509v3 certificate.
            </summary>
            <returns>The key algorithm parameters for the X.509 certificate as a hexadecimal string.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetPublicKey">
            <summary>
            Returns the public key for the X.509v3 certificate.
            </summary>
            <returns>The public key for the X.509 certificate as an array of bytes.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetPublicKeyString">
            <summary>
            Returns the public key for the X.509v3 certificate.
            </summary>
            <returns>The public key for the X.509 certificate as a hexadecimal string.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetRawCertData">
            <summary>
            Returns the raw data for the entire X.509v3 certificate.
            </summary>
            <returns>A byte array containing the X.509 certificate data.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetRawCertDataString">
            <summary>
            Returns the raw data for the entire X.509v3 certificate.
            </summary>
            <returns>The X.509 certificate data as a hexadecimal string.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetSerialNumber">
            <summary>
            Returns the serial number of the X.509v3 certificate.
            </summary>
            <returns>The serial number of the X.509 certificate as an array of bytes.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetSerialNumberString">
            <summary>
            Returns the serial number of the X.509v3 certificate.
            </summary>
            <returns>The serial number of the X.509 certificate as a hexadecimal string.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetPublicKeyLength">
            <summary>
            Returns the length of the public key of the X.509v3 certificate.
            </summary>
            <returns>Returns the length of the public key in bits. If unable to determine the key's length, returns zero.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetDistinguishedName">
            <summary>
            Returns a list of attributes of the X.509v3 certificate.
            </summary>
            <returns>A StringDictionary that contains the attributes.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the attributes.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetExtensions">
            <summary>
            Returns a list of extensions of the X.509v3 certificate.
            </summary>
            <returns>An array of Extension instances.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.FindExtension(System.String)">
            <summary>
            Searches for a certificate extension.
            </summary>
            <param name="oid">The extension to search for.</param>
            <returns>An instance of the <see cref="T:LLCryptoLib.Security.Certificates.Extension"/> class -or- a null reference (<b>Nothing</b> in Visual Basic) if the specified extension could not be found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="oid"/> is a null  reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.DecodeExtension(LLCryptoLib.Security.Certificates.Extension,System.Int32,System.Type)">
            <summary>
            Decodes the specified extension and returns an object of the specified type that is instantiated with the decoded bytes.
            </summary>
            <param name="extension">The certificate extension to decode.</param>
            <param name="oid">One of the predefined constants specified in the Win32 CryptoAPI. Refer to the documentation of the <a href="http://msdn.microsoft.com/library/en-us/security/security/cryptdecodeobject.asp">CryptDecodeObject</a> function for more information.</param>
            <param name="returnType">A <see cref="T:System.Type"/> instance. See remarks.</param>
            <returns>An object of the type <paramref name="returnType"/>.</returns>
            <remarks><p>
            The specified type should have a public constructor that takes an IntPtr and an int as parameters [in that order].
            The IntPtr is a pointer to the decoded buffer and the int contains the number of decoded bytes.
            The type should not keep the IntPtr reference after construction of an instance, because the memory is freed when the DecodeExtension method returns.
            </p></remarks>
            <exception cref="T:System.ArgumentNullException">One of the parameters is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while decoding the certificate extension.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.DecodeExtension(LLCryptoLib.Security.Certificates.Extension,System.String,System.Type)">
            <summary>
            Decodes the specified extension and returns an object of the specified type that is instantiated with the decoded bytes.
            </summary>
            <param name="extension">The certificate extension to decode.</param>
            <param name="oid">The Object Identifier of the structure. Refer to the documentation of the <a href="http://msdn.microsoft.com/library/en-us/security/security/cryptdecodeobject.asp">CryptDecodeObject</a> function for more information.</param>
            <param name="returnType">A <see cref="T:System.Type"/> instance. See remarks.</param>
            <returns>An object of the type <paramref name="returnType"/>.</returns>
            <remarks><p>
            The specified type should have a public constructor that takes an IntPtr and an int as parameters [in that order].
            The IntPtr is a pointer to the decoded buffer and the int contains the number of decoded bytes.
            The type should not keep the IntPtr reference after construction of an instance, because the memory is freed when the DecodeExtension method returns.
            </p></remarks>
            <exception cref="T:System.ArgumentNullException">One of the parameters is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while decoding the certificate extension.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.DecodeExtension(LLCryptoLib.Security.Certificates.Extension,System.IntPtr,System.Type)">
            <summary>
            Decodes the specified extension and returns an object of the specified type that is instantiated with the decoded bytes.
            </summary>
            <param name="extension">The certificate extension to decode.</param>
            <param name="oid">The Object Identifier of the structure.</param>
            <param name="returnType">A <see cref="T:System.Type"/> instance. See remarks.</param>
            <returns>An object of the type <paramref name="returnType"/>.</returns>
            <remarks><p>
            The specified type should have a public constructor that takes an IntPtr and an int as parameters [in that order].
            The IntPtr is a pointer to the decoded buffer and the int contains the number of decoded bytes.
            The type should not keep the IntPtr reference after construction of an instance, because the memory is freed when the DecodeExtension method returns.
            </p></remarks>
            <exception cref="T:System.ArgumentNullException">One of the parameters is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while decoding the certificate extension.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetName">
            <summary>
            Returns the name of the current principal.
            </summary>
            <returns>The name of the current principal.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">The certificate does not have a name attribute.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetIntendedKeyUsage">
            <summary>
            Returns a list of intended key usages of the X.509v3 certificate.
            </summary>
            <returns>An integer that contains a list of intended key usages.</returns>
            <remarks>Use the bitwise And operator to check whether a specific key usage is set.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetEnhancedKeyUsage">
            <summary>
            Returns a list of enhanced key usages of the X.509v3 certificate.
            </summary>
            <returns>A StringCollection that contains a list of the enhanced key usages.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the enhanced key usages.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertificateChain">
            <summary>
            Returns a <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/> where the leaf certificate corresponds to this <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/>.
            </summary>
            <returns>The CertificateChain corresponding to this Certificate.</returns>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while building the certificate chain.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.HasPrivateKey">
            <summary>
            Checks whether the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> has a private key associated with it.
            </summary>
            <returns><b>true</b> if the certificate has a private key associated with it, <b>false</b> otherwise.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetFormat">
            <summary>
            Returns the name of the format of this X.509v3 certificate.
            </summary>
            <returns>The format of this X.509 certificate.</returns>
            <remarks>The format X.509 is always returned in this implementation.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetHashCode">
            <summary>
            Returns the hash code for the X.509v3 certificate as an integer.
            </summary>
            <returns>The hash code for the X.509 certificate as an integer.</returns>
            <remarks>If the X.509 certificate hash is an array of more than 4 bytes, any byte after the fourth byte is not seen in this integer representation.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.Equals(LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Compares two <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> objects for equality.
            </summary>
            <param name="other">A Certificate object to compare to the current object.</param>
            <returns><b>true</b> if the current Certificate object is equal to the object specified by <paramref name="other"/>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.Equals(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Compares a <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> object and an <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate"/> object for equality.
            </summary>
            <param name="other">An X509Certificate object to compare to the current object.</param>
            <returns><b>true</b> if the current Certificate object is equal to the object specified by <paramref name="other"/>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> objects for equality.
            </summary>
            <param name="other">A Certificate object to compare to the current object.</param>
            <returns><b>true</b> if the current Certificate object is equal to the object specified by <paramref name="other"/>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetValidUsages(LLCryptoLib.Security.Certificates.Certificate[])">
            <summary>
            Returns an array of usages consisting of the intersection of the valid usages for all certificates in an array of certificates.
            </summary>
            <param name="certificates">Array of certificates to be checked for valid usage.</param>
            <returns>An array of valid usages -or- a null reference (<b>Nothing</b> in Visual Basic) if all certificates support all usages.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="certificates"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">The array of certificates contains at least one invalid entry.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while determining the intersection of valid usages.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToPfxFile(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> as a PFX encoded file.
            </summary>
            <param name="filename">The filename of the new PFX file.</param>
            <param name="password">The password to use when encrypting the private keys.</param>
            <param name="withPrivateKeys"><b>true</b> if the private keys should be exported [if possible], <b>false</b> otherwise.</param>
            <param name="withParents"><b>true</b> if the parent certificates should be exported too [if possible], <b>false</b> otherwise.</param>
            <remarks>If the specified file already exists, the method will throw an exception.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="filename"/> or <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs while writing the data to the file.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while exporting the certificate store<br>-or-</br><br>an error occurs while building the certificate chain</br><br>-or-</br><br>an error occurs while creating the store</br><br>-or-</br><br>an error occurs while adding the certificate to the store.</br></exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToPfxBuffer(System.String,System.Boolean,System.Boolean)">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> as a PFX encoded buffer.
            </summary>
            <param name="password">The password to use when encrypting the private keys.</param>
            <param name="withPrivateKeys"><b>true</b> if the private keys should be exported [if possible], <b>false</b> otherwise.</param>
            <param name="withParents"><b>true</b> if the parent certificates should be exported too [if possible], <b>false</b> otherwise.</param>
            <returns>An array of bytes that represents the PFX encoded certificate.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while exporting the certificate store<br>-or-</br><br>an error occurs while building the certificate chain</br><br>-or-</br><br>an error occurs while creating the store</br><br>-or-</br><br>an error occurs while adding the certificate to the store.</br></exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateCertStore(System.Boolean)">
            <summary>
            Creates an in memory <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> with this <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> in it.
            </summary>
            <param name="withParents"><b>true</b> if the parent certificates should be included [if possible], <b>false</b> otherwise.</param>
            <returns>A CertificateStore instance.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToCerFile(System.String)">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> as an encoded file.
            </summary>
            <param name="filename">The file where to store the certificate.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="filename"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs while writing the data.</exception>
            <remarks>If the specified file already exists, this method will throw an exception.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToCerBuffer">
            <summary>
            Saves the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> as an encoded buffer.
            </summary>
            <returns>An array of bytes that represents the encoded certificate.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetCertificateBuffer">
            <summary>
            Returns a buffer with the encoded certificate.
            </summary>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.SaveToFile(System.Byte[],System.String)">
            <summary>
            Writes a buffer with data to a file.
            </summary>
            <param name="buffer">The buffer to write.</param>
            <param name="filename">The filename to write the data to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="filename"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.IOException">An error occurs while writing the data.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToX509">
            <summary>
            Returns an X509Certificate object that corresponds to this <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/>.
            </summary>
            <returns>An X509Certificate instance.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.CreateFromBase64String(System.String)">
            <summary>
            Creates a new Certificate from a string representation.
            </summary>
            <param name="rawString">A Base64-encoded representation of the certificate.</param>
            <returns>A new Certificate.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rawString"/> if a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while loading the specified certificate.</exception>
            <exception cref="T:System.FormatException">The length of <paramref name="rawString"/> is less than 4 -or- the length of <paramref name="rawString"/> is not an even multiple of 4.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToBase64String">
            <summary>
            Returns a Base64-encoded representation of the certificate.
            </summary>
            <returns>A Base64-encoded representation of the certificate.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ToPemBuffer">
            <summary>
            Converts the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> to a PEM encoded buffer.
            </summary>
            <returns>An array of bytes that represents the PEM encoded certificate.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.GetKeyIdentifier">
            <summary>
            Gets the unique identifier associated with the key.
            </summary>
            <returns>A byte array containing the unique identifier associated with the key.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ConvertIntToByteArray(System.Int32)">
            <summary>
            Converts an integer to a series of bytes.
            </summary>
            <param name="dwInput">The integer to convert.</param>
            <returns>An array of bytes that represents the integer.</returns>
            <remarks>This method returns the minimum required number of bytes to represent a specific integer number.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.AssociateWithPrivateKey(System.String,System.String)">
            <summary>
            Associates the certificate with a private key from a PVK file.
            </summary>
            <param name="pvkFile">The path to the PVK file to open.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <remarks>
            <p>The <paramref name="password"/> can be a null reference (<b>Nothing</b> in Visual Basic) if the private key is not encrypted.</p>
            <p>The private key will not be exportable.</p>
            </remarks>
            <exception cref="T:System.ArgumentNullException">The PVK file is encrypted and <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified file could not be found.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while importing the private key.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.AssociateWithPrivateKey(System.String,System.String,System.Boolean)">
            <summary>
            Associates the certificate with a private key from a PVK file.
            </summary>
            <param name="pvkFile">The path to the PVK file to open.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <param name="exportable"><b>true</b> if the private key should be marked exportable, <b>false</b> otherwise.</param>
            <remarks>The <paramref name="password"/> can be a null reference (<b>Nothing</b> in Visual Basic) if the private key is not encrypted.</remarks>
            <exception cref="T:System.ArgumentNullException">The PVK file is encrypted and <paramref name="password"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified file could not be found.</exception>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while importing the private key.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.ExportPrivateKey(System.String,System.String)">
            <summary>
            Exports the private key of this certificate to a PVK file.
            </summary>
            <param name="pvkFile">The path to the PVK file to create.</param>
            <param name="password">The password used to encrypt the private key.</param>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while exporting the private key.</exception>
            <exception cref="T:System.IO.IOException">An error occurs while writing the PVK file.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.TryDecrypt(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Tries decrypting the PRIVATEKEYBLOB blob.
            </summary>
            <param name="buffer">The buffer to decrypt.</param>
            <param name="offset">The starting offset.</param>
            <param name="length">The number of bytes to decrypt.</param>
            <param name="password">The password used to encrypt the PVK file (the salt should be prepended to the password).</param>
            <param name="keyLen">The effective key length in bytes (16 for 128 bit encryption, 5 for 40 bit encryption).</param>
            <returns>The decrypted buffer if successfull, or a null reference otherwise.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Certificate.VerifyRevocation(System.Byte[])">
            <summary>
            Verifies whether this certificate has been revoked or not.
            </summary>
            <param name="crl">The encoded CRL to check against.</param>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while verifying the certificate.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="crl"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <returns><b>true</b> if the certificate is not on the CRL and therefore valid, or <b>false</b> if the certificate is on the CRL and therefore revoked.</returns>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Certificate.m_Handle">
            <summary>
            The handle of the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> object.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Certificate.m_Store">
            <summary>
            The handle of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/> object.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Certificate.m_CertInfo">
            <summary>
            A <see cref="T:LLCryptoLib.Security.CertificateInfo"/> instance associated with this certificate.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Certificate.m_Context">
            <summary>
            A <see cref="T:LLCryptoLib.Security.CertificateContext"/> instance associated with this certificate.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Certificate.m_Chain">
            <summary>
            A reference to the associated <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/>.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Certificate.Handle">
            <summary>
            Gets the handle of the Certificate.
            </summary>
            <value>An IntPtr that represents the handle of the certificate.</value>
            <remarks>The handle returned by this property should not be closed. If the handle is closed by an external actor, the methods of the Certificate object may fail in undocumented ways [for instance, an Access Violation may occur].</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Certificate.Store">
            <summary>
            Gets the handle of the associated <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>, if any.
            </summary>
            <value>A CertificateStore instance -or- a null reference (<b>Nothing</b> in Visual Basic) is no store is associated with this certificate.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Certificate.IsCurrent">
            <summary>
            Gets a value indicating whether the certificate is current, that is, has not expired.
            </summary>
            <value><b>true</b> if the certificate is current; otherwise, <b>false</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Certificate.SupportsDataEncryption">
            <summary>
            Gets a value indicating whether the certificate can be used for encrypting and decrypting messages.
            </summary>
            <value><b>true</b> if the certificate can be used for data encryption; otherwise, <b>false</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Certificate.SupportsDigitalSignature">
            <summary>
            Gets a value indicating whether the certificate can be used for digital signatures.
            </summary>
            <value><b>true</b> if the certificate can be used for digital signature; otherwise, <b>false</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Certificate.PrivateKey">
            <summary>
            Gets the private key for the certificate.
            </summary>
            <value>A System.Security.Cryptography.RSA containing the private key for the certificate.</value>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the RSA instance associated with the certificate.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.Certificate.PublicKey">
            <summary>
            Gets the public key derived from the certificate's data. This key cannot be used to sign or decrypt data.
            </summary>
            <value>A System.Security.Cryptography.RSA that contains the public key derived from the certificate's data.</value>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while retrieving the RSA instance associated with the certificate.</exception>
        </member>
        <member name="T:LLCryptoLib.HexStyle">
            <summary>
            Hexadecimal representation style
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyle.UNKNOWN">
            <summary>
            An unknown hexadecimal style
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyle.CLASSIC">
            <summary>
            Classic hexadecimal style: FF12AB4D
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyle.UNIX">
            <summary>
            UNIX hexadecimal style: ff12ab4d
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyle.SPACE">
            <summary>
            SPACE hexadecimal style: FF 12 AB 4D
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyle.NETSCAPE">
            <summary>
            Netscape(TM) hexadecimal style: FF:12:AB:4D
            </summary>
        </member>
        <member name="F:LLCryptoLib.HexStyle.MODERN">
            <summary>
            Modern hexadecimal style: ff 12 ab 4d
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.Utilities">
            <summary>A container of static utility functions.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.#ctor">
            <summary>Prevent the compiler from making an unneeded default public constructor.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUShort(System.Byte[])">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUShort(System.Byte[],LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="endian">The order in which to read the bytes.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUShort(System.Byte[],System.Int32,System.Int32)">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many bytes in the array to convert.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUShort(System.Byte[],System.Int32,System.Int32,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many bytes in the array to convert.</param>
            <param name="endian">The order in which to read the bytes.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUInt(System.Byte[])">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUInt(System.Byte[],LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="endian">The order in which to read the bytes.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUInt(System.Byte[],System.Int32,System.Int32)">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many bytes in the array to convert.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToUInt(System.Byte[],System.Int32,System.Int32,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many bytes in the array to convert.</param>
            <param name="endian">The order in which to read the bytes.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToULong(System.Byte[])">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToULong(System.Byte[],LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="endian">The order in which to read the bytes.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToULong(System.Byte[],System.Int32,System.Int32)">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many bytes in the array to convert.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToULong(System.Byte[],System.Int32,System.Int32,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many bytes in the array to convert.</param>
            <param name="endian">The order in which to read the bytes.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UShortToByte(System.UInt16)">
            <summary>Converts an unsigned short integer to an array of bytes.</summary>
            <param name="data">The unsigned short integer to convert.</param>
            <returns>The unsigned short integer represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UShortToByte(System.UInt16,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an unsigned short integer to an array of bytes.</summary>
            <param name="data">The unsigned short integer to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned short integer represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UShortToByte(System.UInt16[])">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UShortToByte(System.UInt16[],LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UShortToByte(System.UInt16[],System.Int32,System.Int32)">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many unsigned short integers in the array to convert.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UShortToByte(System.UInt16[],System.Int32,System.Int32,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned short integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many unsigned short integers in the array to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned short integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UIntToByte(System.UInt32)">
            <summary>Converts an unsigned integer to an array of bytes.</summary>
            <param name="data">The unsigned integer to convert.</param>
            <returns>The unsigned integer represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UIntToByte(System.UInt32,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an unsigned integer to an array of bytes.</summary>
            <param name="data">The unsigned integer to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned integer represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UIntToByte(System.UInt32[])">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UIntToByte(System.UInt32[],LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UIntToByte(System.UInt32[],System.Int32,System.Int32)">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many unsigned integers in the array to convert.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.UIntToByte(System.UInt32[],System.Int32,System.Int32,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many unsigned integers in the array to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ULongToByte(System.UInt64)">
            <summary>Converts an unsigned long integer to an array of bytes.</summary>
            <param name="data">The unsigned long integer to convert.</param>
            <returns>The unsigned long integer represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ULongToByte(System.UInt64,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an unsigned long integer to an array of bytes.</summary>
            <param name="data">The unsigned long integer to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned long integer represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ULongToByte(System.UInt64[])">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ULongToByte(System.UInt64[],LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ULongToByte(System.UInt64[],System.Int32,System.Int32)">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many unsigned long integers in the array to convert.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
            <remarks>Assumes Little Endian.</remarks>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ULongToByte(System.UInt64[],System.Int32,System.Int32,LLCryptoLib.Hash.EndianType)">
            <summary>Converts an array of unsigned long integers to an array of bytes.</summary>
            <param name="array">The array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many unsigned long integers in the array to convert.</param>
            <param name="endian">The order in which to store the bytes.</param>
            <returns>The unsigned long integers represented as a byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToHexadecimal(System.Byte)">
            <summary>Convert a byte into a hexadecimal string.</summary>
            <param name="data">The byte to convert.</param>
            <returns>A string containing the hexadecimal equivelent of the byte.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToHexadecimal(System.Byte[])">
            <summary>Convert a byte array into a hexadecimal string.</summary>
            <param name="array">The byte array to convert.</param>
            <returns>A string containing the hexadecimal equivelent of the byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.ByteToHexadecimal(System.Byte[],System.Int32,System.Int32)">
            <summary>Convert a byte array into a hexadecimal string.</summary>
            <param name="array">The byte array to convert.</param>
            <param name="offset">Position in the array to begin the conversion.</param>
            <param name="length">How many bytes in the array to convert.</param>
            <returns>A string containing the hexadecimal equivelent of the byte array.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.RotateRight(System.UInt16,System.Int32)">
            <summary>Rotates the bits of an unsigned short integer.</summary>
            <param name="x">The unsigned short integer to rotate.</param>
            <param name="shift">How many bits to rotate.</param>
            <returns>The rotated unsigned short integer.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.RotateRight(System.UInt32,System.Int32)">
            <summary>Rotates the bits of an unsigned integer.</summary>
            <param name="x">The unsigned integer to rotate.</param>
            <param name="shift">How many bits to rotate.</param>
            <returns>The rotated unsigned integer.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.RotateRight(System.UInt64,System.Int32)">
            <summary>Rotates the bits of an unsigned long integer.</summary>
            <param name="x">The unsigned long integer to rotate.</param>
            <param name="shift">How many bits to rotate.</param>
            <returns>The rotated unsigned long integer.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.RotateLeft(System.UInt16,System.Int32)">
            <summary>Rotates the bits of an unsigned short integer.</summary>
            <param name="x">The unsigned short integer to rotate.</param>
            <param name="shift">How many bits to rotate.</param>
            <returns>The rotated unsigned short integer.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.RotateLeft(System.UInt32,System.Int32)">
            <summary>Rotates the bits of an unsigned integer.</summary>
            <param name="x">The unsigned integer to rotate.</param>
            <param name="shift">How many bits to rotate.</param>
            <returns>The rotated unsigned integer.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.Utilities.RotateLeft(System.UInt64,System.Int32)">
            <summary>Rotates the bits of an unsigned long integer.</summary>
            <param name="x">The unsigned long integer to rotate.</param>
            <param name="shift">How many bits to rotate.</param>
            <returns>The rotated unsigned long integer.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.SHA0">
            <summary>Computes the SHA0 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA0.#ctor">
            <summary>Initializes a new instance of the SHA0 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA0.Initialize">
            <summary>Initializes an implementation of System.Security.Cryptography.HashAlgorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA0.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA0.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.RIPEMD256">
            <summary>Computes the RIPEMD256 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD256.#ctor">
            <summary>Initializes a new instance of the RIPEMD256 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD256.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD256.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD256.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.MD5">
            <summary>Computes the MD5 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD5.#ctor">
            <summary>Initializes a new instance of the MD5 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD5.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD5.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.MD5.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many blocks have been processed so far.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.GOSTHash">
            <summary>Computes the GOSTHash hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.GOSTHash.#ctor">
            <summary>Initializes a new instance of the GOSTHash class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.GOSTHash.#cctor">
            <summary>Initializes the substitution boxes.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.GOSTHash.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.GOSTHash.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.GOSTHash.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.FCS16">
            <summary>Computes the FCS16 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS16.#ctor">
            <summary>Initializes a new instance of the FCS16 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS16.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS16.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS16.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.Cksum">
            <summary>Computes the Cksum hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Cksum.#ctor">
            <summary>Initializes a new instance of the Cksum class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Cksum.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Cksum.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Cksum.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextPseudoDes">
            <summary>
            PseudoDES text encoding class.
            PseudoDES is a TextVigenere type of encoding, remade
            for a number of times equal to TextAlgorithmParameters.Shift.
            If TextAlgorithmParameters.Shift is zero, then a value of 7
            is taken.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextVigenere">
            <summary>
            Implements Vigenere/Polyalphabetical Text Crypto Algorithm.
            The Vigenere encryption was the creation of the French diplomat, Blaise de Vigenere, 1523-1596. 
            Like Caesar and all the cryptographers that followed, he did not visualize the cipher in modular 
            arithmetical terms. Rather he viewed the cypher as a substitution cipher where a different alphabet 
            was used for the next letter of the message, with the alphabets repeating periodically --- according 
            to some key. Rather than setting several different alphabets, the cryptographer would use the Vigenere 
            square.
            
            Here's the idea. For the given key word "FIRST", encrypt each letter of the message taken in the 
            left-most column to the letter in the keyword-letter column. Thus, the first five letters of the 
            message use the alphabets corresponding the the "F", "I", "R", "S", and "T" columns. So, the 
            Vigenere code with this keyword is really five Caesar shifts used in a cyclical fashion. Decription 
            is carried out working backwards from the keyword-columns to the left-most column. Because we are 
            really using five alphabets, the Vigenere encryption is sometimes called a polyalphabetic 
            (many + alphbets) code. 
            </summary>
            <example>Polyalphabetical text encryption:
            <code>
            TextAlgorithmParameters parms = new TextAlgorithmParameters(3);
            TextCrypter textEncrypter = TextCrypterFactory.Create(SupportedTextAlgorithms.POLYALPHABETIC,parms);
            string encrypted = textEncrypter.TextEncryptDecrypt(origString, true);
            Console.WriteLine("Encrypted string: " + encrypted);
            string decrypted = textEncrypter.TextEncryptDecrypt(encrypted, false);
            Console.WriteLine("Decrypted string: " + decrypted);
            Console.WriteLine();
            </code>
            </example>
        </member>
        <member name="F:LLCryptoLib.Crypto.TextVigenere.shift">
            <summary>
            Algorithm shift number
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.TextVigenere.key">
            <summary>
            Algorithm key string
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextVigenere.#ctor(LLCryptoLib.Crypto.TextAlgorithmParameters)">
            <summary>
            Constructor
            </summary>
            <param name="p">Parametri must have a valid key</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextVigenere.Code(System.String)">
            <summary>
            Return coded string
            </summary>
            <param name="txt">input clear string</param>
            <returns>coded string</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextVigenere.Decode(System.String)">
            <summary>
            Decode
            </summary>
            <param name="txt">coded string</param>
            <returns>clear string</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextVigenere.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextVigenere.Algo(System.String,System.Boolean)">
            <summary>
            Encoding algorithm
            </summary>
            <param name="text">Encoded or decoded text</param>
            <param name="coding">If true coding, else decoding</param>
            <returns>An encoded/decoded string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextPseudoDes.#ctor(LLCryptoLib.Crypto.TextAlgorithmParameters)">
            <summary>
            Constructor
            </summary>
            <param name="p">Parametri must have a valid key</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextPseudoDes.Code(System.String)">
            <summary>
            Encoding algorithm
            </summary>
            <param name="txt">Plain text</param>
            <returns>Encoded text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextPseudoDes.Decode(System.String)">
            <summary>
            Decoding algorithm
            </summary>
            <param name="txt">Encoded text</param>
            <returns>Decoded text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextPseudoDes.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextAlgorithmType">
            <summary>
            The type of text algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.TextAlgorithmType.TEXT">
            <summary>
            This algorithm works by scrambling alphabetic letters and numbers
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.TextAlgorithmType.BINARY">
            <summary>
            This algorithm works by scrambling bytes. String representations are handled by Base64 conversions
            </summary>
        </member>
        <member name="T:LLCryptoLib.CallbackPoint">
            <summary>
            Delegate for displaying advancement. This is a delegate to 
            call a piece of code whenever a certain event happens on
            the main computing loop.
            </summary>
            <example>
            <code>
            //0. Update counter is a method with signature FeedbackExample(int i, string message)
            CallbackPoint cbp = new CallbackPoint(FeedbackExample.UpdateCounter);
            
            //1. Encrypt with Rijndael
            StreamARC4512 cryptAlgorithm = LLCryptoLib.Crypto.StreamAlgorithmFactory.ArcFour512;
            LLCryptoLib.Crypto.StreamCrypter crypter = new StreamCrypter(cryptAlgorithm);
            crypter.GenerateKeys("password");
            string encryptedFile = rndFile.FullName + ".enc";
            // here we use the CallbackPoint
            crypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, cbp);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.HMAC">
            <summary>
            Implements the HMAC keyed message authentication code algorithm.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.HMAC.#ctor(System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.HMAC"/> class. This class cannot be inherited.
            </summary>
            <param name="hash">The underlying hash algorithm to use.</param>
            <remarks>A random key will be generated and used by the HMAC.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="hash"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.HMAC.#ctor(System.Security.Cryptography.HashAlgorithm,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.HMAC"/> class.
            </summary>
            <param name="hash">The underlying hash algorithm to use.</param>
            <param name="rgbKey">The key to use for the HMAC -or- a null reference (<b>Nothing</b> in Visual Basic).</param>
            <remarks>If <paramref name="rgbKey"/> is a null reference, the HMAC class will generate a random key.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="hash"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.HMAC.Initialize">
            <summary>
            Initializes the HMAC.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The HMAC instance has been disposed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.HMAC.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Routes data written to the object into the hash algorithm for computing the hash.
            </summary>
            <param name="array">The input for which to compute the hash code. </param>
            <param name="ibStart">The offset into the byte array from which to begin using data. </param>
            <param name="cbSize">The number of bytes in the byte array to use as data. </param>
            <exception cref="T:System.ObjectDisposedException">The HMAC instance has been disposed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.HMAC.HashFinal">
            <summary>
            Finalizes the hash computation after the last data is processed by the cryptographic stream object.
            </summary>
            <returns>The computed hash code.</returns>
            <exception cref="T:System.ObjectDisposedException">The HMAC instance has been disposed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.HMAC.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by the HMAC.
            </summary>
            <param name="disposing"><b>true</b> to release both managed and unmanaged resources; <b>false</b> to release only unmanaged resources.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.HMAC.Finalize">
            <summary>
            Finalizes the HMAC.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.HMAC.HashSize">
            <summary>
            Gets the size of the computed hash code in bits.
            </summary>
            <value>The size of the computed hash code in bits.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.RevocationItem">
            <summary>
            Revocation item structure class.
            It associates a certificate with a boolean value (revoked or not).
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationItem.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.RevocationItem"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="owner">The owner.</param>
            <param name="revoked">if set to <c>true</c> [revoked].</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationItem.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.RevocationItem.Certificate">
            <summary>
            Gets or sets the certificate serial number.
            </summary>
            <value>The certificate serial number.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.RevocationItem.Owner">
            <summary>
            Gets or sets the certificate owner.
            </summary>
            <value>The certificate owner.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.RevocationItem.Revoked">
            <summary>
            Gets or sets a value indicating whether this Certificate is revoked.
            </summary>
            <value><c>true</c> if revoked; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateVerificationResult">
            <summary>
            Represents the status of an asynchronous certificate chain verification operation.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateVerificationResult.#ctor(LLCryptoLib.Security.Certificates.CertificateChain,System.String,LLCryptoLib.Security.Certificates.AuthType,LLCryptoLib.Security.Certificates.VerificationFlags,System.AsyncCallback,System.Object)">
            <summary>
            Initializes a new CertificateVerificationResult instance.
            </summary>
            <param name="chain">The <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/> that has to be verified.</param>
            <param name="server">The server to which the <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> has been issued.</param>
            <param name="type">One of the <see cref="T:LLCryptoLib.Security.Certificates.AuthType"/> values.</param>
            <param name="flags">One of the <see cref="T:LLCryptoLib.Security.Certificates.VerificationFlags"/> values.</param>
            <param name="callback">The delegate to call when the verification finishes.</param>
            <param name="asyncState">User-defined state data.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateVerificationResult.VerificationCompleted(System.Exception,LLCryptoLib.Security.Certificates.CertificateStatus)">
            <summary>
            Sets the WaitHandle to signalled and calls the appropriate delegate.
            </summary>
            <param name="error">An exception that may have occurred.</param>
            <param name="status">The status of the certificate chain.</param>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_IsCompleted">
            <summary>Holds the value of the IsCompleted property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_AsyncState">
            <summary>Holds the value of the AsyncState property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_Chain">
            <summary>Holds the value of the Chain property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_Server">
            <summary>Holds the value of the Server property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_Type">
            <summary>Holds the value of the Type property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_Flags">
            <summary>Holds the value of the Flags property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_WaitHandle">
            <summary>Holds the value of the WaitHandle property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_Callback">
            <summary>Holds the value of the Callback property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_HasEnded">
            <summary>Holds the value of the HasEnded property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_ThrowException">
            <summary>Holds the value of the ThrowException property.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateVerificationResult.m_Status">
            <summary>Holds the value of the Status property.</summary>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.CompletedSynchronously">
            <summary>
            Gets an indication of whether the asynchronous operation completed synchronously.
            </summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.IsCompleted">
            <summary>
            Gets a boolean value that indicates whether the operation has finished.
            </summary>
            <value>
            <b>true</b> if the verification of the chain has been completed, <b>false</b> otherwise.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.AsyncWaitHandle">
            <summary>
            Gets a <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.
            </summary>
            <value>
            A WaitHandle that is used to wait for an asynchronous operation to complete.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.AsyncState">
            <summary>
            Gets a user-defined object that qualifies or contains information about an asynchronous operation.
            </summary>
            <value>
            A user-defined object that qualifies or contains information about an asynchronous operation.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.Chain">
            <summary>
            Gets the associated certificate chain.
            </summary>
            <value>
            A <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/> instance.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.Server">
            <summary>
            Gets the associated server name.
            </summary>
            <value>
            A string that holds the server name.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.Type">
            <summary>
            Gets the associated authentication type.
            </summary>
            <value>
            One of the <see cref="T:LLCryptoLib.Security.Certificates.AuthType"/> values.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.Flags">
            <summary>
            Gets the associated verification flags.
            </summary>
            <value>
            One of the <see cref="T:LLCryptoLib.Security.Certificates.VerificationFlags"/> values.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.HasEnded">
            <summary>
            Gets or sets a value that indicates whether the user has called EndVerifyChain for this object.
            </summary>
            <value>
            <b>true</b> if the user has called EndVerifyChain, <b>false</b> otherwise.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.ThrowException">
            <summary>
            Gets an exception that has occurred while verifying the certificate chain or a null reference (<b>Nothing</b> in Visual Basic) if the verification succeeded.
            </summary>
            <value>
            A <see cref="T:System.Exception"/> instance.
            </value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.CertificateVerificationResult.Status">
            <summary>
            Gets the status of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateChain"/>.
            </summary>
            <value>
            One of the <see cref="T:LLCryptoLib.Security.Certificates.CertificateStatus"/> values.
            </value>
        </member>
        <member name="T:LLCryptoLib.Hash.SumBSD">
            <summary>Computes the BSD-style checksum for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SumBSD.#ctor">
            <summary>Initializes a new instance of the SumBSD class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SumBSD.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SumBSD.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Performs the hash algorithm on the data provided.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SumBSD.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.SHA384">
            <summary>Computes the SHA384 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA384.#ctor">
            <summary>Initializes a new instance of the SHA384 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA384.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA384.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA384.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.MD4">
            <summary>Computes the MD4 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD4.#ctor">
            <summary>Initializes a new instance of the MD4 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD4.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD4.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.MD4.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes should be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.GHashStandard">
            <summary>Predefined standard parameters for GHash algorithms.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.GHashStandard.GHash_3">
            <summary>GHash with a shift of 3 bits.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.GHashStandard.GHash_5">
            <summary>GHash with a shift of 5 bits.</summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamDES">
            <summary>
            DES 64bit.
            DES is an algorithm developed in the 1970s. It was made a standard by the US government, and has also 
            been adopted by several other governments worldwide. It is widely used, especially in the financial industry.
            DES is a block cipher with 64-bit block size. It uses 56-bit keys. This makes it fairly easy to break with modern 
            computers or special-purpose hardware. DES is still strong enough to keep most random hackers and individuals out, 
            but it is easily breakable with special hardware by government, criminal organizations, or major corporations. 
            In large volumes, the cost of beaking DES keys is on the order of tens of dollars. DES is getting too weak, 
            and should not be used in new designs.
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamDES();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamDES.#ctor">
            <summary>
            DES 64 bit constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamDES.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.DES
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamDES.Algorithm">
            <summary>
            Returns a DES 64 bit implementation
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.Stream3DES">
            <summary>
            3DES 128bit
            A variant of DES, Triple-DES or 3DES is based on using DES three times (an encrypt-decrypt-encrypt sequence with three different, 
            unrelated keys). Many people consider Triple-DES to be much safer than plain DES.
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new Stream3DES();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.Stream3DES.#ctor">
            <summary>
            Triple DES 128 bit constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.Stream3DES.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.TRIPLEDES
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.Stream3DES.Algorithm">
            <summary>
            Returns a 3DES implementation
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamBlowfish">
            <summary>
            StreamBlowfish implements Blowfish for streams.
            Key len = 16 byte
            Block len = 8 byte
            </summary>
            <example>
            Perform a Blowfish stream encryption.
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamBlowfish();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamBlowfish.#ctor">
            <summary>
            StreamBlowfish constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamBlowfish.SupportedAlgorithmID">
            <summary>
            Return SupportedStreamAlgorithms.BLOWFISH
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamBlowfish.Algorithm">
            <summary>
            Return a newly constructed SymmetricAlgorithm of type BlowfishManaged
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamBlowfish256">
            <summary>
            StreamBlowfish 256 bit
            Key len = 32 byte
            Block len = 8 byte
            <example>
            Perform a Blowfish stream encryption.
            <code>  
            Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamBlowfish256();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamBlowfish256.#ctor">
            <summary>
            StreamBlowfish 256 constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamBlowfish256.SupportedAlgorithmID">
            <summary>
            Return SupportedStreamAlgorithms.BLOWFISH256
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamBlowfish256.Algorithm">
            <summary>
            Return a newly constructed SymmetricAlgorithm of type BlowfishManaged
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamBlowfish448">
            <summary>
            StreamBlowfish 448 bit
            Key len = 56 byte
            Block len = 8 byte
            <example>
            Perform a Blowfish stream encryption.
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamBlowfish448();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamBlowfish448.#ctor">
            <summary>
            StreamBlowfish 448 constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamBlowfish448.SupportedAlgorithmID">
            <summary>
            Return SupportedStreamAlgorithms.BLOWFISH448
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamBlowfish448.Algorithm">
            <summary>
            Return a newly constructed SymmetricAlgorithm of type BlowfishManaged
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.Shredder">
            <summary>
            Shredder.
            The shredder class is tipically called in this way:
            <pre lang="cs">
            Shredder s = new Shredder(new Random())
            FileInfo theFile = new FileInfo(@"C:\temp\log.txt");
            IShredMethod method = ShredMethods.Get(AvailableShred.COMPLEX);
            if (s.WipeFile(theFile, method, true))
            {
                log("File shredded.");
            }
            </pre>
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.#ctor(System.Random)">
            <summary>
            Constructor.
            </summary>
            <param name="rand">A random seed</param>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.WipeFile(System.IO.FileInfo,LLCryptoLib.Shred.IShredMethod,System.Boolean)">
            <summary>
            Wipe a file
            </summary>
            <param name="filePath">Complete file path of file to be wiped</param>
            <param name="method">Shredding method</param>
            <param name="delete">If false it just rewrites the file and filename. If true, rewrites and then delete.</param>
            <returns>True if the file has been successfully shredded</returns>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.WipeFile(System.IO.FileInfo,LLCryptoLib.Shred.IShredMethod,LLCryptoLib.CallbackEntry,LLCryptoLib.CallbackPoint,System.Boolean)">
            <summary>
            Wipe a file with a feedback on operation progress
            </summary>
            <param name="filePath">Complete file path of file to be wiped</param>
            <param name="method">Shredding method</param>
            <param name="cbe">Callback entry point for feedback. The callback method will be called every 1024 bytes shredded. An integer will be passed to callback method with the current kilobyte being erased. For instance, if you want to erase a 200kb file, this delegate will call the method for 200 times passing to it integers from 1 to 200.</param>
            <param name="phase">The phase feedback message</param>
            <param name="delete">If false it just rewrites the file and filename. If true, rewrites and then delete</param>
            <returns>
            True if the file has been successfully shredded
            </returns>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.WipeFile(System.IO.FileInfo,LLCryptoLib.Shred.IShredMethod,LLCryptoLib.CallbackEntry,LLCryptoLib.CallbackPoint,System.Threading.AutoResetEvent,System.Boolean)">
            <summary>
            Wipe a file with a feedback on operation progress and an autoreset event requese.
            </summary>
            <param name="filePath">Complete file path of file to be wiped</param>
            <param name="method">Shredding method</param>
            <param name="cbe">Callback entry point for feedback. The callback method will be called every 1024 bytes shredded. An integer will be passed to callback method with the current kilobyte being erased. For instance, if you want to erase a 200kb file, this delegate will call the method for 200 times passing to it integers from 1 to 200.</param>
            <param name="phase">The phase feedback message</param>
            <param name="resEvent">A stop operations request event. If set, the method stop current operation and returns false</param>
            <param name="delete">If false it just rewrites the file and filename. If true, rewrites and then delete</param>
            <returns>
            True if the file has been successfully shredded
            </returns>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.GetRandomFolderName(System.Int32)">
            <summary>
            Random folder name
            </summary>
            <param name="characters">The number of characters in the folder name</param>
            <returns>A random folder name of 'characters' length</returns>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.GetRandomFileName(System.UInt32)">
            <summary>
            Return a random filename
            </summary>
            <param name="characters">The number of characters in the file name</param>
            <returns>A random filename of 'characters' number of character. A dot will be placed before the last three characters, ie: ejeskjekjw.ejh</returns>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.WipeEmptyDir(System.IO.DirectoryInfo)">
            <summary>
            Wipe an empty directory: rename old empty directory and
            then deletes it. Two passes: rename each dir, then delete each renamed dir.
            </summary>
            <param name="di">The directory to be wiped</param>
            <returns>The random name to which the directory was named before it was deleted</returns>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.WipeFile(System.String,LLCryptoLib.Shred.IShredMethod,LLCryptoLib.CallbackEntry,LLCryptoLib.CallbackPoint,System.Threading.AutoResetEvent)">
            <summary>
            Wipe single file
            </summary>
            <param name="fullName">Full path to file</param>
            <param name="method">Shredding method</param>
            <param name="fileShreddingFeedback">Callback entry point for feedback (can be null). The callback method will be called every 1024 bytes shredded. An integer will be passed to callback method with the current kilobyte being erased. For instance, if you want to erase a 200kb file, this delegate will call the method for 200 times passing to it integers from 1 to 200.</param>
            <param name="phaseFeedback">The phase feedback. A delegate is called at any shredding phase. IE: if the shredding method overwrites 3 times with 0x00, 0xff, 0x00, the delegate is called 3 times with the current byte being written as a message.</param>
            <param name="resetReq">A reset request</param>
            <returns>True if the file was correctly wiped out</returns>
        </member>
        <member name="M:LLCryptoLib.Shred.Shredder.GetChunkSequence(System.Byte)">
            <summary>
            This method initializes the chunk array to be written in chunks on disk
            </summary>
            <param name="fillingByte">The byte for this phase sequence, ie: FF</param>
            <returns>A circa 2000 bytes length byte array filled with sequence</returns>
        </member>
        <member name="P:LLCryptoLib.Shred.Shredder.LastShreddedPath">
            <summary>
            Gets the full path to the last shredded file or folder
            </summary>
            <value>The last shredded path.</value>
        </member>
        <member name="P:LLCryptoLib.Shred.Shredder.ErrorMessage">
            <summary>
            Error message
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.Shredder.ChunkSize">
            <summary>
            Gets the size of the chunk (length in bytes of the single shredding step).
            </summary>
            <returns>The size length in bytes of the single shredding step</returns>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredGermanVSITR">
            <summary>
            HMG Infosec Standard 5 Enhanced shred method.
            This shred method overwrites the file area with 0's, 1's and finally a random byte.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredGermanVSITR.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Shred.ShredGermanVSITR"/> class.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredGermanVSITR.Name">
            <summary>
            Shredding method Name
            </summary>
            <value></value>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredGermanVSITR.Id">
            <summary>
            Shredding method Available Shred Enum
            </summary>
            <value></value>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredGermanVSITR.Description">
            <summary>
            Shredding method Detailed description
            </summary>
            <value></value>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform">
            <summary>
            Represents an ARCFour managed ICryptoTransform.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the ARCFourManagedTransform class.
            </summary>
            <param name="key">The key used to initialize the ARCFour state.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inputOffset"/>, <paramref name="inputCount"/> or <paramref name="outputOffset"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inputOffset"/> or <paramref name="inputCount"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.Init">
            <summary>
            This method (re)initializes the cipher.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.Dispose">
            <summary>
            Disposes of the cryptographic parameters.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.Finalize">
            <summary>
            Finalizes the object.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
            <value>This property returns <b>true</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
            <value>This property returns <b>true</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.InputBlockSize">
            <summary>
            Gets the input block size.
            </summary>
            <value>The size of the input data blocks in bytes.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.ARCFourManagedTransform.OutputBlockSize">
            <summary>
            Gets the output block size.
            </summary>
            <value>The size of the input data blocks in bytes.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.ARCFourManaged">
            <summary>
            Accesses the managed version of the ARCFour algorithm. This class cannot be inherited.
            ARCFour is fully compatible with the RC4<sup>TM</sup> algorithm.
            </summary>
            <remarks>
            RC4 is a trademark of RSA Data Security Inc.
            </remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManaged.#ctor">
            <summary>
            Initializes a new instance of the ARCFourManaged class.
            </summary>
            <remarks>
            The default keysize is 128 bits.
            </remarks>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManaged.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates a symmetric <see cref="T:LLCryptoLib.Security.Cryptography.RC4"/> decryptor object with the specified Key.
            </summary>
            <param name="rgbKey">The secret key to be used for the symmetric algorithm.</param>
            <param name="rgbIV">This parameter is not used an should be set to a null reference, or to an array with zero or one bytes.</param>
            <returns>A symmetric ARCFour decryptor object.</returns>
            <remarks>This method decrypts an encrypted message created using the <see cref="M:LLCryptoLib.Security.Cryptography.ARCFourManaged.CreateEncryptor(System.Byte[],System.Byte[])"/> overload with the same signature.</remarks>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.Security.Cryptography.CryptographicException"/>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManaged.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates a symmetric <see cref="T:LLCryptoLib.Security.Cryptography.RC4"/> encryptor object with the specified Key.
            </summary>
            <param name="rgbKey">The secret key to be used for the symmetric algorithm.</param>
            <param name="rgbIV">This parameter is not used an should be set to a null reference, or to an array with zero or one bytes.</param>
            <returns>A symmetric ARCFour encryptor object.</returns>
            <remarks>Use the <see cref="M:LLCryptoLib.Security.Cryptography.ARCFourManaged.CreateDecryptor(System.Byte[],System.Byte[])"/> overload with the same signature to decrypt the result of this method.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.ARCFourManaged.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:LLCryptoLib.Security.Cryptography.ARCFourManaged"/> and optionally releases the managed resources.
            </summary>
            <param name="disposing"><b>true</b> to release both managed and unmanaged resources; <b>false</b> to release only unmanaged resources.</param>
        </member>
        <member name="T:LLCryptoLib.Hash.RIPEMD320">
            <summary>Computes the RIPEMD320 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD320.#ctor">
            <summary>Initializes a new instance of the RIPEMD320 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD320.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD320.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD320.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>\
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.HAVAL">
            <summary>Computes the HAVAL hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.HAVAL.#ctor(LLCryptoLib.Hash.HAVALParameters)">
            <summary>Initializes a new instance of the HAVAL class.</summary>
            <param name="param">The parameters to utilize in the HAVAL calculation.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.HAVAL.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.HAVAL.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.HAVAL.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.FNVAlgorithmType">
            <summary>Represents a variation of the FNV hashing algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVAlgorithmType.FNV1">
            <summary>The mainstream FNV algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVAlgorithmType.FNV1A">
            <summary>The alternate FNV algorithm.</summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextTripleDES">
            <summary>
            Triple DES for text.
            When encrypting, the algorithm is applied to the byte encoding of the input text, see <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.StringToBytes(System.String)"/>,
            then, after encryption, rendered to a Base64 string with <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.MemoryToBase64String(System.IO.MemoryStream)"/>.
            When decrypting, the text is first trasformed into a byte sequence with <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.Base64StringToBytes(System.String)"/>,
            then decrypted, then the resulting bytes are transformed to a string with <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.MemoryToString(System.IO.MemoryStream)"/>
            </summary>
            <example>
            <code>
            TextAlgorithmParameters parms = new TextAlgorithmParameters("llcryptopassword");
            TextCrypter textEncrypter = new TextCrypter(new TextTripleDES(parms));
            encrypted = textEncrypter.Base64EncryptDecrypt(origString, true);
            Console.WriteLine("Encrypted string: " + encrypted);
            decrypted = textEncrypter.Base64EncryptDecrypt(encrypted, false);
            Console.WriteLine("Decrypted string: " + decrypted);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextTripleDES.#ctor(LLCryptoLib.Crypto.TextAlgorithmParameters)">
            <summary>
            Triple DES class.
            Key size can be 16 or 24 bytes
            Block size must be 8 bytes
            </summary>
            <param name="p">Parameters (key and shift)</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextTripleDES.Code(System.String)">
            <summary>
            Code using DES algoritml
            </summary>
            <param name="txt">String text to code (text must be UTF8 compatible)</param>
            <returns>Base64 representation of text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextTripleDES.Decode(System.String)">
            <summary>
            Decode using DES algorithm
            </summary>
            <param name="txt"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextTripleDES.EncryptData(System.Byte[],System.Boolean)">
            <summary>
            Encrypts/Decrypts using DES algorithm
            </summary>
            <param name="txt">Bytes to crypt/decrypt in bytes</param>
            <param name="isCrypting">If true, crypt, else decrypt</param>
            <returns></returns>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform">
            <summary>
            Defines the basic operations of a unmanaged Rijndael cryptographic transformation.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.#ctor(LLCryptoLib.Security.Cryptography.CryptoAlgorithm,LLCryptoLib.Security.Cryptography.CryptoMethod,System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Int32,System.Security.Cryptography.PaddingMode)">
            <summary>
            Initializes a new instance of the RijndaelUnmanagedTransform class.
            </summary>
            <param name="algorithm">One of the <see cref="T:LLCryptoLib.Security.Cryptography.CryptoAlgorithm"/> values.</param>
            <param name="method">One of the <see cref="T:LLCryptoLib.Security.Cryptography.CryptoMethod"/> values.</param>
            <param name="key">The key to use.</param>
            <param name="iv">The IV to use.</param>
            <param name="mode">One of the <see cref="T:System.Security.Cryptography.CipherMode"/> values.</param>
            <param name="feedback">The feedback size of the cryptographic operation in bits.</param>
            <param name="padding">One of the <see cref="T:System.Security.Cryptography.PaddingMode"/> values.</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs when acquiring the cryptographic context.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.Finalize">
            <summary>
            Releases all unmanaged resources.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.Dispose">
            <summary>
            Releases all unmanaged resources.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">One of the specified offsets or lengths is invalid.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while transforming the specified data.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The combination of offset and length is invalid.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while transforming the specified data.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
            <value><b>true</b> if the current transform can be reused; otherwise, <b>false</b>.</value>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
            <value><b>true</b> if multiple blocks can be transformed; otherwise, <b>false</b>.</value>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.InputBlockSize">
            <summary>
            Gets the input block size.
            </summary>
            <value>The size of the input data blocks in bytes.</value>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelUnmanagedTransform.OutputBlockSize">
            <summary>
            Gets the output block size.
            </summary>
            <value>The size of the output data blocks in bytes.</value>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider">
            <summary>
            Computes the <see cref="T:LLCryptoLib.Security.Cryptography.MD4"/> hash for the input data using the implementation provided by the cryptographic service provider (CSP).
            </summary>
            <remarks>Warning: The MD4 algorithm is a broken algorithm. It should <i>only</i> be used for compatibility with older systems.</remarks>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.MD4">
            <summary>
            Represents the abstract class from which all implementations of the MD4 hash algorithm inherit.
            </summary>
            <remarks>Warning: The MD4 algorithm is a broken algorithm. It should <i>only</i> be used for compatibility with older systems.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:LLCryptoLib.Security.Cryptography.MD4"/>.
            </summary>
            <remarks>You cannot create an instance of an abstract class. Application code will create a new instance of a derived class.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4.Create">
            <summary>
            Creates an instance of the default implementation of the <see cref="T:LLCryptoLib.Security.Cryptography.MD4"/> hash algorithm.
            </summary>
            <returns>A new instance of the MD4 hash algorithm.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4.Create(System.String)">
            <summary>
            Creates an instance of the specified implementation of the <see cref="T:LLCryptoLib.Security.Cryptography.MD4"/> hash algorithm.
            </summary>
            <param name="hashName">The name of the specific implementation of MD4 to use.</param>
            <returns>A new instance of the specified implementation of MD4.</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while initializing the hash.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider"/> class. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider.Initialize">
            <summary>
            Initializes an instance of <see cref="T:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The MD4CryptoServiceProvider instance has been disposed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Routes data written to the object into the <see cref="T:LLCryptoLib.Security.Cryptography.MD4"/> hash algorithm for computing the hash.
            </summary>
            <param name="array">The array of data bytes.</param>
            <param name="ibStart">The offset into the byte array from which to begin using data.</param>
            <param name="cbSize">The number of bytes in the array to use as data.</param>
            <exception cref="T:System.ObjectDisposedException">The MD4CryptoServiceProvider instance has been disposed.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The data could not be hashed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider.HashFinal">
            <summary>
            Returns the computed <see cref="T:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider"/> hash as an array of bytes after all data has been written to the object.
            </summary>
            <returns>The computed hash value.</returns>
            <exception cref="T:System.ObjectDisposedException">The MD4CryptoServiceProvider instance has been disposed.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The data could not be hashed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider"/> and optionally releases the managed resources.
            </summary>
            <param name="disposing"><b>true</b> to release both managed and unmanaged resources; <b>false</b> to release only unmanaged resources.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD4CryptoServiceProvider.Finalize">
            <summary>
            Finalizes the MD4CryptoServiceProvider.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.LLCertificate">
            <summary>
            Wrapper around <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/> class.
            Holds information about certificate path and format
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificate.CreateFromPemString(System.String)">
            <summary>
            Creates a new certificate from a PEM/Base64 string.
            </summary>
            <param name="pemContents">The PEM contents.</param>
            <returns>A newly created LLCertificate object</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificate.CreateCertificate(System.String,LLCryptoLib.Security.Certificates.CertificateFormat)">
            <summary>
            Creates the certificate from a DER/PEM file
            </summary>
            <param name="path">The path of DER/PER file.</param>
            <param name="format">The certificate format as in <see cref="T:LLCryptoLib.Security.Certificates.CertificateFormat"/></param>
            <returns>A newly created LLCertificate object</returns> 
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificate.CreateCertificate(System.String,System.String)">
            <summary>
            Creates the certificate from a PFX file
            </summary>
            <param name="path">The certificate PFX path.</param>
            <param name="password">The certificate password (usually for a PFX file).</param>
            <returns>A newly created LLCertificate object</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificate.#ctor(LLCryptoLib.Security.Certificates.Certificate)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.LLCertificate"/> class.
            </summary>
            <param name="cert">The cert.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificate.GetChain">
            <summary>
            Gets the chain.
            </summary>
            <returns>The certificate chain of this certificate</returns>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.Path">
            <summary>
            Gets or sets the path.
            </summary>
            <value>The path.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.FileFormat">
            <summary>
            Gets or sets the file format.
            </summary>
            <value>The file format.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.EffectiveDate">
            <summary>
            Gets the effective date.
            </summary>
            <value>The effective date.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.ToDate">
            <summary>
            Gets to date.
            </summary>
            <value>To date.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.Format">
            <summary>
            Gets the format.
            </summary>
            <value>The format.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.Hash">
            <summary>
            Gets the hash.
            </summary>
            <value>The hash.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.SerialNumber">
            <summary>
            Gets the serial number.
            </summary>
            <value>The serial number.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.Issuer">
            <summary>
            Gets the issuer.
            </summary>
            <value>The issuer.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.KeyAlgorithm">
            <summary>
            Gets the key algorithm.
            </summary>
            <value>The key algorithm.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.KeyParameters">
            <summary>
            Gets the key parameters.
            </summary>
            <value>The key parameters.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.PublicKeyStr">
            <summary>
            Gets the public key as a hexadecimal string.
            </summary>
            <value>The public key.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.PrivateKeyXml">
            <summary>
            Gets the private key as an XML string.
            </summary>
            <value>If this certificate contains a private key, return the private key as XML. Else return null.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificate.PublicKeyXml">
            <summary>
            Gets the public key as an XML string.
            </summary>
            <value>The public key.</value>
        </member>
        <member name="T:LLCryptoLib.Hash.SupportedHashAlgo">
            <summary>
            SupportedHashAlgo.
            Container for any supported Hash Algorithm.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgo.GetHashCode">
            <summary>
            A hash code for HashTable calculus. 
            </summary>
            <returns>A hash code for HashTable calculus</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgo.ToString">
            <summary>
            The name of the hash algorithm
            </summary>
            <returns>The name of the hash algorithm</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgo.Equals(System.Object)">
            <summary>
            If two SupportedHashAlgo are the same
            </summary>
            <param name="obj">Another SupportedHashAlgo</param>
            <returns>True if the name of the two algorithms are the same</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.SupportedHashAlgo.Id">
            <summary>
            Hash Algorithm ID
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.SupportedHashAlgo.Name">
            <summary>
            Hash Algorithm Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.SupportedHashAlgo.Description">
            <summary>
            Hash Algorithm Description
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.SupportedHashAlgo.IsKeyed">
            <summary>
            If the Algorithm is keyed
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.SupportedHashAlgo.IsFast">
            <summary>
            If the Algorithm is supposed to be fast 
            </summary>
        </member>
        <member name="P:LLCryptoLib.Hash.SupportedHashAlgo.Algorithm">
            <summary>
            The HashAlgorithm
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.MD2">
            <summary>Computes the MD2 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD2.#ctor">
            <summary>Initializes a new instance of the MD2 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD2.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.MD2.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.MD2.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The final block of data to process.</param>
            <param name="inputOffset">Where to start in the array.</param>
            <param name="inputCount">How many bytes should be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.FNV">
            <summary>Computes the FNV hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FNV.#ctor(LLCryptoLib.Hash.FNVParameters)">
            <summary>Initializes a new instance of the FNV class.</summary>
            <param name="param">The parameters to utilize in the FNV calculation.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.FNV.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FNV.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.FNV.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.SupportedStreamAlgorithms">
             <summary>
             Available symmetric encryption algorithms.
             </summary>
             <example><code>
             
             // 1. Set algorithm
             IStreamAlgorithm cryptoAlgo = StreamAlgorithmFactory.Create(SupportedStreamAlgorithms.BLOWFISH);
            
             // 2. Encrypt 
             StreamCrypter crypter = new StreamCrypter(cryptoAlgo);
             crypter.GenerateKeys("littlelitesoftware");
             crypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
             Console.WriteLine("File encrypted into " + encryptedFile);
            
             // 3. Decrypt
             StreamCrypter decrypter = new StreamCrypter(cryptoAlgo);
             crypter.GenerateKeys("littlelitesoftware");
             crypter.EncryptDecrypt(encryptedFile, decryptedFile, false, null);
             Console.WriteLine("File decrypted into " + decryptedFile);
             
             </code></example>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.DES">
            <summary>
            DES
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.TRIPLEDES">
            <summary>
            Triple DES or 3DES
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.RIJNDAEL">
            <summary>
            Rijndael or AES 128 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.AES128">
            <summary>
            AES or Rijndael 128 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.AES192">
            <summary>
            AES or Rijndael 192 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.AES256">
            <summary>
            AES or Rijndael 256 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.ARC4">
            <summary>
            ARC4 128 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.ARC4512">
            <summary>
            ARC4 512 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.ARC41024">
            <summary>
            ARC4 1024 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.ARC42048">
            <summary>
            ARC4 2048 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.TWOFISH">
            <summary>
            Twofish 128 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.TWOFISH256">
            <summary>
            Twofish 256 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.BLOWFISH">
            <summary>
            Blowfish 128 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.BLOWFISH256">
            <summary>
            Blowfish 256 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.BLOWFISH448">
            <summary>
            Blowfish 448 bit
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedStreamAlgorithms.XOR">
            <summary>
            XOR
            </summary>
        </member>
        <member name="T:LLCryptoLib.Config">
            <summary>
            Configuration items.
            TextEncoding = Encoding for TextTransformations
            CULTURE = Default Culture info
            NUMBER_FORMAT = Default Number Format
            </summary>
        </member>
        <member name="F:LLCryptoLib.Config.TextEncoding">
            <summary>
            TextEncoding = Unicode
            </summary>
        </member>
        <member name="F:LLCryptoLib.Config.NUMBERFORMAT">
            <summary>
            The number format in the current culture
            </summary>
        </member>
        <member name="T:LLCryptoLib.Utils.FileManager">
            <summary>
            File Manager. 
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.IsFileNameValid(System.String)">
            <summary>
            Check if filename is valid (does not contain invalid characters)
            </summary>
            <param name="inputFileName">Name of the input file.</param>
            <returns>
            	<c>true</c> if [is filename valid] [the specified input file name]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.WriteBinaryFile(System.String,System.Byte[])">
            <summary>
            Write a binary file
            </summary>
            <param name="filePath">The file path.</param>
            <param name="contents">The file contents.</param>
            <returns>True if the file was correctly written</returns>
            <remarks>In case this method return false, check <see cref="P:LLCryptoLib.Utils.FileManager.ErrorMessage"/></remarks>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.IsReadOnly(System.String)">
            <summary>
            Returns true if the given file is Read only
            </summary>
            <param name="fullName">Full file path</param>
            <returns>True if the given file is Read only</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.SetReadOnly(System.String,System.Boolean)">
            <summary>
            Set the attribute read only of a file
            </summary>
            <param name="fullName">Full path of file</param>
            <param name="readOnly">If true, the file will be set readonly. Else will be set writable</param>
            <remarks>In case this method return false, check <see cref="P:LLCryptoLib.Utils.FileManager.ErrorMessage"/></remarks>
            <returns>True, if the attribute was set</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.SetHidden(System.String,System.Boolean)">
            <summary>
            Set the attribute read only of a file
            </summary>
            <param name="fullName">Full path of file.</param>
            <param name="hidden">if set to <c>true</c> then the file will be hidden, else the hidden attribute will be removed.</param>
            <returns>True, if the attribute was set</returns>
            <remarks>In case this method return false, check <see cref="P:LLCryptoLib.Utils.FileManager.ErrorMessage"/></remarks>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ReadBinaryFile(System.String)">
            <summary>
            Read a binary file. This method reads a small binary file.
            Since it does not implement a cache, it is not suitable for large files.
            </summary>
            <param name="filePath">Absolute Path of file to read from.</param>
            <example>byte[] myFile = myFileObj.ReadBinaryFile(@"C:\log.txt");</example>
            <remarks>In case this method return false, check <see cref="P:LLCryptoLib.Utils.FileManager.ErrorMessage"/></remarks>
            <returns>Byte contents of the file.</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">Input file too long</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ReadTextFile(System.String)">
            <summary>
            Reads a text file.
            </summary>
            <param name="filePath">The file path.</param>
            <remarks>In case this method return 'null', check <see cref="P:LLCryptoLib.Utils.FileManager.ErrorMessage"/>.</remarks>
            <returns>The content of the read file as a string.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ReadTextFile(System.String,System.Text.Encoding)">
            <summary>
            Reads a text file.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="enc">The text encoding.</param>
            <returns>
            The content of the read file as a string.
            </returns>
            <remarks>In case this method return 'null', check <see cref="P:LLCryptoLib.Utils.FileManager.ErrorMessage"/>.</remarks>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.RenameFile(System.String,System.String)">
            <summary>
            Rename a file
            </summary>
            <param name="pathSource">Complete path of the file to be renamed</param>
            <param name="newname">New name of the file - without path</param>
            <returns>True if operation was successful</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ReadFile(System.String)">
            <summary>
            Reads a Text File
            </summary>
            <param name="absolutePath">Absolute Path of file to read from</param>
            <returns>Text Contents of the file</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ReadFile(System.String,System.Text.Encoding)">
            <summary>
            Reads a Text File
            </summary>
            <param name="absolutePath">Absolute Path of file to read from</param>
            <param name="enc">Encoding of the text file. Use Encoding static members.</param>
            <returns>Text Contents of the file</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.FileLines(System.String)">
            <summary>
            Returns the number of lines inside a text file
            </summary>
            <param name="absolutePath">The absolute path.</param>
            <returns>The number of lines inside a text file</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ReadFileLines(System.String)">
            <summary>
            Reads a Text File Line by Line. Return an array of strings,
            using the default encoding.
            </summary>
            <param name="absolutePath">Absolute Path of file to read from</param>
            <returns>Text Contents of the file (one string per line)</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ReadFileLines(System.String,System.Text.Encoding)">
            <summary>
            Reads a Text File Line by Line. Return an array of strings.
            </summary>
            <param name="absolutePath">Absolute Path of file to read from</param>
            <param name="enc">Encoding of the text file. Use Encoding static members.</param>
            <returns>Text Contents of the file (one string per line)</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.DeleteFile(System.String)">
            <summary>
            Delete file
            </summary>
            <param name="absolutePath">Absolute path of file to delete</param>
            <returns>True if file was actually deleted</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.SaveFile(System.String,System.String)">
            <summary>
            Save File
            </summary>
            <param name="absolutePath">Absolute path of file to save</param>
            <param name="contents">String contents</param>
            <returns>True, if file was correctly saved. If false, read ErrorMessage property to know what happened</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.FileSize(System.String)">
            <summary>
            Get the size of a file
            </summary>
            <param name="fileName">Name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.SaveFile(System.String,System.String,System.Boolean)">
            <summary>
            Save File as UTF-8 text file
            </summary>
            <param name="absolutePath">Absolute path of file to sav</param>
            <param name="contents">String contents</param>
            <param name="append">If true, contents will be append to absolutePath</param>
            <returns>True, if file was correctly saved. If false, read ErrorMessage property to know what happened</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">Trying SaveFile with an empty filename</exception>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.ExistFile(System.String)">
            <summary>
            File Existance
            </summary>
            <param name="absolutePath"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.GetPath(System.String)">
            <summary>
            Return the path of a file, given its absolute path complete of file name.
            It returns the string without the file name, and without the last "\".
            </summary>
            <param name="completeAbsolutePath">absolute path complete of file name</param>
            <returns>A string representing the path of the file</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.FileManager.Exists(System.String)">
            <summary>
            If the given file or directory exists
            </summary>
            <param name="fileOrDirectoryPath">The file or directory path.</param>
            <returns>True if this file or directory exists</returns>
        </member>
        <member name="P:LLCryptoLib.Utils.FileManager.ErrorMessage">
            <summary>
            Error Message. Every time it's called, reset ErrorMessage to "".
            </summary>
        </member>
        <member name="P:LLCryptoLib.Utils.FileManager.Reference">
            <summary>
            Get the only instance of this class (singleton).
            </summary>
            <returns>Handle to FileManager object</returns>
        </member>
        <member name="T:LLCryptoLib.Security.SecurityException">
            <summary>
            The exception that is thrown when a security error is detected.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.SecurityException.#ctor">
            <summary>
            Initializes a new instance of the SecurityException class with default properties.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.SecurityException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SecurityException class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:LLCryptoLib.Security.SecurityException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SecurityException class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="inner">The exception that is the cause of the current exception. If the <paramref name="inner"/> parameter is not a null reference (<b>Nothing</b> in Visual Basic), the current exception is raised in a catch block that handles the inner exception.</param>
        </member>
        <member name="M:LLCryptoLib.Security.SecurityException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the SecurityException class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.RevocationList">
            <summary>
            A revocation list class
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationList.ListName(LLCryptoLib.Security.Certificates.LLCertificateStore)">
            <summary>
            Get the CRL name
            </summary>
            <param name="store">The store.</param>
            <returns>The name of the list</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationList.#ctor(LLCryptoLib.Security.Certificates.LLCertificateStore)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.RevocationList"/> class.
            </summary>
            <param name="store">The store.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationList.UpdateRevocation(System.String,System.Boolean)">
            <summary>
            Updates the revocation of a certificate.
            </summary>
            <param name="serial">The serial.</param>
            <param name="revoked">if set to <c>true</c> [revoked].</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationList.GetCRL">
            <summary>
            Gets the CRL.
            </summary>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationList.#ctor(LLCryptoLib.Security.Certificates.StoreLocation,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.RevocationList"/> class.
            </summary>
            <param name="location">The location.</param>
            <param name="name">The name.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.RevocationList.SerializeCRL">
            <summary>
            Serializes this instance.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.RevocationList.Store">
            <summary>
            Gets the store.
            </summary>
            <value>The store.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateFormat">
            <summary>
            Certificate file format
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateFormat.BASE64">
            <summary>
            Base64
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateFormat.DER">
            <summary>
            DER
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateFormat.PEM">
            <summary>
            PEM
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateFormat.PKCS7">
            <summary>
            PKCS7
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateFormat.PKCS12">
            <summary>
            PKCS12
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateFormat.UNKNOWN">
            <summary>
            Unknown format
            </summary>
        </member>
        <member name="T:LLCryptoLib.LLCryptoLibException">
            <summary>
            LLCryptoLibException.
            </summary>
        </member>
        <member name="M:LLCryptoLib.LLCryptoLibException.#ctor">
            <summary>
            LLCryptoLibException object
            </summary>
        </member>
        <member name="M:LLCryptoLib.LLCryptoLibException.#ctor(System.String)">
            <summary>
            LLCryptoLibException object
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:LLCryptoLib.LLCryptoLibException.#ctor(System.String,System.Exception)">
            <summary>
            LLCryptoLibException object
            </summary>
            <param name="message">Exception message</param>
            <param name="innerException">Inner exception object</param>
        </member>
        <member name="M:LLCryptoLib.LLCryptoLibException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            LLCryptoLibException object
            </summary>
            <param name="info">Serialization Info handle</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="T:LLCryptoLib.Hash.CRCStandard">
            <summary>Predefined standards for CRC algorithms.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC8">
            <summary>The standard CRC8 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC16_IBM">
            <summary>The IBM standard CRC16 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC16_CCITT">
            <summary>The CCITT standard CRC16 algorithm. Used in things such as X.25, SDLC, and HDLC.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC16_ARC">
            <summary>A variation on the CRC16 algorithm. Used in ARC.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC16_XMODEM">
            <summary>A variation on the CRC16 algorithm. Used in XMODEM.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC16_ZMODEM">
            <summary>A variation on the CRC16 algorithm. Used in ZMODEM.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC24">
            <summary>The standard CRC24 algorithm. Used in things such as PGP.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC32">
            <summary>The standard CRC32 algorithm. Used in things such as PKZip, SFV, AUTODIN II, Ethernet, and FDDI.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC32_JAMCRC">
            <summary>A variation on the CRC32 algorithm. Used in JAMCRC.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC32_BZIP2">
            <summary>A variation on the CRC32 algorithm. Used in BZip2.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC64_ISO">
            <summary>The ISO standard CRC64 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.CRCStandard.CRC64_ECMA">
            <summary>The ECMA standard CRC64 algorithm.</summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamCrypter">
             <summary>
             This class wraps the operations on encryption streams.
             </summary>
             <example><code>
             
              // 1. Set algorithm
              IStreamAlgorithm cryptoAlgo = StreamAlgorithmFactory.Create(SupportedStreamAlgorithms.BLOWFISH);
            
              // 2. Encrypt 
              StreamCrypter crypter = new StreamCrypter(cryptoAlgo);
              crypter.GenerateKeys("littlelitesoftware");
              crypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
              Console.WriteLine("File encrypted into " + encryptedFile);
            
              // 3. Decrypt
              StreamCrypter decrypter = new StreamCrypter(cryptoAlgo);
              crypter.GenerateKeys("littlelitesoftware");
              crypter.EncryptDecrypt(encryptedFile, decryptedFile, false, null);
              Console.WriteLine("File decrypted into " + decryptedFile);
             
             </code></example>
        </member>
        <member name="F:LLCryptoLib.Crypto.StreamCrypter.CACHESIZE">
            <summary>
            The size of the buffer when reading and writing files.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.#ctor(LLCryptoLib.Crypto.IStreamAlgorithm)">
            <summary>
            Initializes a new instance of the <see cref="T:StreamCrypter"/> class.
            </summary>
            <param name="algo">an encryption algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.GenerateKeys(System.String)">
            <summary>
            Generate keys starting from a string password. This method transforms a normal string into a strong password
            by applying hash trasformation on that. The strong password is
            then used to create the key vector and the block vector to
            run the algorithm.
            </summary>
            <param name="password">a given password</param>
            <example><code>
            
            // 1. Set algorithm
            IStreamAlgorithm cryptoAlgo = StreamAlgorithmFactory.Create(SupportedStreamAlgorithms.BLOWFISH);
            
            // 2. Encrypt 
            StreamCrypter crypter = new StreamCrypter(cryptoAlgo);
            crypter.GenerateKeys("littlelitesoftware");
            crypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            
            // 3. Decrypt
            StreamCrypter decrypter = new StreamCrypter(cryptoAlgo);
            crypter.GenerateKeys("littlelitesoftware");
            crypter.EncryptDecrypt(encryptedFile, decryptedFile, false, null);
            Console.WriteLine("File decrypted into " + decryptedFile);
            
            </code></example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.MemoryEncryptDecrypt(System.String,System.Boolean,LLCryptoLib.CallbackPoint)">
            <summary>
            Encrypt or decrypt a file into a MemoryStream
            </summary>
            <param name="inputFile">Path to input file</param>
            <param name="isCrypting">True if encryption, False if decryption</param>
            <param name="cbp">A feebback callback handle</param>
            <returns>the encrypted file as an array of bytes</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.EncryptDecrypt(System.String,System.String,System.Boolean,LLCryptoLib.CallbackPoint)">
             <summary>
             Encrypt or decrypt a file.
             </summary>
             <param name="inputFile">File to read. If isCrypting, clear file else encrypted file.</param>
             <param name="outputFile">File to write. if isCrypting, encrypted file.</param>
             <param name="isCrypting">True if encryption, false if decryption.</param>
             <param name="cbp">The feedback will be filled with 1 point each CACHE_SIZE wrote.</param>
             <example><code>
             
             // 1. Set algorithm
             IStreamAlgorithm cryptoAlgo = StreamAlgorithmFactory.Create(SupportedStreamAlgorithms.BLOWFISH);
            
             // 2. Encrypt 
             StreamCrypter crypter = new StreamCrypter(cryptoAlgo);
             crypter.GenerateKeys("littlelitesoftware");
             crypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
             Console.WriteLine("File encrypted into " + encryptedFile);
            
             // 3. Decrypt
             StreamCrypter decrypter = new StreamCrypter(cryptoAlgo);
             crypter.GenerateKeys("littlelitesoftware");
             crypter.EncryptDecrypt(encryptedFile, decryptedFile, false, null);
             Console.WriteLine("File decrypted into " + decryptedFile);
             
             </code></example>
             <exception cref="T:LLCryptoLib.LLCryptoLibException"/>
             <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.EncryptDecrypt(System.IO.FileStream,System.IO.FileStream,System.Boolean,LLCryptoLib.CallbackPoint)">
             <summary>
             Encrypt or decrypt a file stream.
             </summary>
             <param name="inStream">File stream to read from. If isCrypting, clear file stream else a encrypted file stream.</param>
             <param name="outStream">File stream to write to. if isCrypting, a encrypted file stream.</param>
             <param name="isCrypting">True if encryption, false if decryption.</param>
             <param name="cbp">The feedback will be filled with 1 point each CACHE_SIZE wrote.</param>
             <example><code>
             
             // 1. Set algorithm
             IStreamAlgorithm cryptoAlgo = StreamAlgorithmFactory.Create(SupportedStreamAlgorithms.BLOWFISH);
            
             // 2. Encrypt 
             StreamCrypter crypter = new StreamCrypter(cryptoAlgo);
             crypter.GenerateKeys("littlelitesoftware");
             crypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
             Console.WriteLine("File encrypted into " + encryptedFile);
            
             // 3. Decrypt
             StreamCrypter decrypter = new StreamCrypter(cryptoAlgo);
             crypter.GenerateKeys("littlelitesoftware");
             crypter.EncryptDecrypt(encryptedFile, decryptedFile, false, null);
             Console.WriteLine("File decrypted into " + decryptedFile);
             
             </code></example>
             <exception cref="T:LLCryptoLib.LLCryptoLibException"/>
             <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamCrypter.Algorithm">
            <summary>
            Gets the wrapped symmetric algorithm.
            </summary>
            <value>the encryption algorithm of this Stream Crypter</value>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamCrypter.KeyFactory">
            <summary>
            The KeyFactory class generates symmetric algorithm keys
            according to the choosen algorithm
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.KeyFactory.#ctor(System.Security.Cryptography.SymmetricAlgorithm,System.Int16,System.Int16)">
            <summary>
            KeyFactory constructor.
            </summary>
            <param name="sa">Encryption algorithm</param>
            <param name="keyLen">Length in bits of the key</param>
            <param name="blockLen">Length in bits of the block</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.KeyFactory.GenerateKeys(System.String)">
            <summary>
            This method transforms a normal string into a strong password
            by applying hash trasformation on that. The strong password is
            then used to create the key vector and the block vector to
            run the algorithm.
            </summary>
            <param name="password"></param>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.KeyFactory.Code(System.String)">
            <summary>
            Returns null
            </summary>
            <param name="a">A string</param>
            <returns>Null</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamCrypter.KeyFactory.Decode(System.String)">
            <summary>
            Returns null
            </summary>
            <param name="b">A string</param>
            <returns>Null</returns>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamCrypter.KeyFactory.Key">
            <summary>
            Get the computed key in bytes
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamCrypter.KeyFactory.Block">
            <summary>
            Get the computed block in bytes
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamAES">
            <summary>
            AES 128bit. The American Encyption Standard recogninized by NIST (National Institute of Standards and Technology)
            The AES, aka Rijndael, is a cipher by two Belgian cryptographers, Joan Daemen and Vincent Rijmen.
            Rijndael follows the tradition of square ciphers (it is based on ideas similar to the Square cipher). 
            NIST gave as its reasons for selecting Rijndael that it performs very well in hardware and software 
            across a wide range of environments in all possible modes. It has excellent key setup time and has 
            low memory requirements, in addition its operations are easy to defend against power and timing attacks. 
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamAES();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAES.#ctor(System.Int16,System.Int16,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="keylen">Length of key in bytes</param>
            <param name="blocksize">Length of block in bytes</param>
            <param name="description">Description of algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAES.#ctor">
            <summary>
            Constructor.
            Defaults to 16 bytes keylen and blocklen (128 bits).
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAES.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.AES128
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAES.Algorithm">
            <summary>
            Return the corresponding SymmetricAlgorithm
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamAES192">
            <summary>
            AES 192bit.
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamAES192();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAES192.#ctor">
            <summary>
            Constructor.
            Defaults to 24 bytes keylen and blocklen (192 bits).
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAES192.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.AES192
            </summary>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamAES256">
            <summary>
            AES 256bit
            </summary>
            <example>
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = new StreamAES256();
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAES256.#ctor">
            <summary>
            Constructor.
            Defaults to 32 bytes keylen and blocklen (256 bits)
            </summary>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAES256.SupportedAlgorithmID">
            <summary>
            Returns SupportedStreamAlgorithms.AES256
            </summary>
        </member>
        <member name="T:LLCryptoLib.Alfa">
            <summary>
            Utility class to handle alphabetic shifts.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Alfa.IsInAlfa(System.Char)">
            <summary>
            Return true if character is in Alfa string
            </summary>
            <param name="car">Character to be checked</param>
            <returns>True if car is inside the Alfa string</returns>
        </member>
        <member name="M:LLCryptoLib.Alfa.GetCharAt(System.Int32)">
            <summary>
            Return the char in BETO at position pos
            </summary>
            <param name="pos">Position</param>
            <returns>Corresponding char in BETO string</returns>
        </member>
        <member name="M:LLCryptoLib.Alfa.GetPosOf(System.Char)">
            <summary>
            Get position of char 'car' in BETO string
            </summary>
            <param name="car">Character</param>
            <returns>Position</returns>
        </member>
        <member name="P:LLCryptoLib.Alfa.Characters">
            <summary>
            Get a string with utf-8 alphanumeric characters
            </summary>
        </member>
        <member name="P:LLCryptoLib.Alfa.CharactersLen">
            <summary>
            Return the number of characters in Characters string
            </summary>
            <returns>The number of characters in BETO string</returns>
        </member>
        <member name="T:LLCryptoLib.Utils.WinRegistry">
            <summary>
            Writes/Read from registry
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.HKLMExists(System.String)">
            <summary>
            Check if HKLM key exist
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.HKCUExists(System.String)">
            <summary>
            Check if HKCU key exists.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.CreateHKCRKey(System.String)">
            <summary>
            Create an HKCR key. Does not produce errors if the key exists.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.DeleteHKLMKeyAll(System.String)">
            <summary>
            Delete HKLM key and all of its subkeys
            </summary>
            <param name="key">Example: SOFTWARE\LittleLite Software\NCrypt</param>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.DeleteHKLMKey(System.String)">
            <summary>
            Delete HKLM key without deleting key's subkeys
            </summary>
            <param name="key">Example: SOFTWARE\LittleLite Software\NCrypt</param>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.DeleteHKLMValue(System.String,System.String)">
            <summary>
             Delete an HKLM value
            </summary>
            <param name="keypath">Key name, Example: SOFTWARE\LittleLite Software\NCrypt</param>
            <param name="keyValue">Key value: Example: Size</param>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.DeleteHKCUValue(System.String,System.String)">
            <summary>
             Delete an HKLM value
            </summary>
            <param name="keypath">Key name, Example: SOFTWARE\LittleLite Software\NCrypt</param>
            <param name="keyValue">Key value: Example: Size</param>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.DeleteHKCRKey(System.String)">
            <summary>
            Deletes a key in HKCR
            </summary>
            <param name="key">Example: SOFTWARE\LittleLite Software\NCrypt</param>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.DeleteHKCUKey(System.String)">
            <summary>
            Deletes a key in HKCU
            </summary>
            <param name="key">Example: SOFTWARE\LittleLite Software\NCrypt</param>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKLMValues(System.String)">
            <summary>
            
            </summary>
            <param name="keypath"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKCUValues(System.String)">
            <summary>
            
            </summary>
            <param name="keypath"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKCUSubkeys(System.String)">
            <summary>
            
            </summary>
            <param name="keypath"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKLMSubkeys(System.String)">
            <summary>
            
            </summary>
            <param name="keypath"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKCRValue(System.String,System.String,System.String)">
            <summary>
            Get the value of a key in a registry HKCR (classes) subkey
            </summary>
            <param name="keypath">Path of subkey, ie: Folder</param>
            <param name="keyname">Name of the key</param>
            <param name="name">Name of the value</param>
            <returns>The string if correctly read, null else</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKCUBlob(System.String,System.String)">
            <summary>
            Gets the HKCU BLOB.
            </summary>
            <param name="keyname">The keyname.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKLMBlob(System.String,System.String)">
            <summary>
            Gets the HKLM BLOB.
            </summary>
            <param name="keyname">The keyname.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKLMValue(System.String,System.String)">
            <summary>
            Get the value of a key in a registry HKLM\Software subkey
            </summary>
            <param name="keyname">Name of the key</param>
            <param name="name">Name of the value</param>
            <returns>The string if correctly read, null else</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKCUValue(System.String,System.String)">
            <summary>
            Get the value of a key in a registry "HKCU (Current User)\Software" subkey
            </summary>
            <param name="keyname">Name of the key</param>
            <param name="name">Name of the value</param>
            <returns>The string if correctly read, null else</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetHKCUDWORDValue(System.String,System.String)">
            <summary>
            Get the value of a key in a registry "HKCU (Current User)\Software" subkey
            </summary>
            <param name="keyname">Name of the key</param>
            <param name="name">Name of the value</param>
            <returns>The number if correctly read, null else</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.SetHKCRValue(System.String,System.String,System.String,System.String)">
            <summary>
            Adds a keypair to an existing key under the HKCR branch.
            If any error (ie: key does not exist) return false.
            </summary>
            <param name="keypath">Path of an EXISTING key: ie: Folder</param>
            <param name="keyname">Name of the key </param>
            <param name="name"></param>
            <param name="valkey"></param>
            <returns>True if key is correctly set.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.SetHKLMBlob(System.String,System.String,System.Byte[])">
            <summary>
            Sets the HKLM BLOB.
            </summary>
            <param name="keyname">The keyname.</param>
            <param name="name">The name.</param>
            <param name="valkey">The valkey.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.SetHKCUBlob(System.String,System.String,System.Byte[])">
            <summary>
            Sets the HKCU BLOB.
            </summary>
            <param name="keyname">The keyname.</param>
            <param name="name">The name.</param>
            <param name="valkey">The valkey.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.SetHKLMValue(System.String,System.String,System.String)">
            <summary>
            Adds a keypair to an existing key under the HKLM\Software branch.
            If any error (ie: key does not exist) return false.
            </summary>
            <param name="keyname">Name of an existing key</param>
            <param name="name">Name of the key value</param>
            <param name="valkey">Value to be set</param>
            <returns>True if key is correctly set.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.SetHKCUValue(System.String,System.String,System.String)">
            <summary>
            Adds a keypair to an existing key under the HKCU (Current User)\Software branch.
            If any error return false.
            If key does not exist, it will be created.
            </summary>
            <param name="keyname">Name of an existing key</param>
            <param name="name">Name of key-value pair</param>
            <param name="valkey">Value to associate to this key</param>
            <returns>True if key is correctly set.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.SetHKCUValue(System.String,System.String,System.Int32)">
            <summary>
            Adds a keypair to an existing key under the HKCU (Current User)\Software branch.
            If any error return false.
            If key does not exist, it will be created.
            </summary>
            <param name="keyname">Name of an existing key</param>
            <param name="name">Name of key-value pair</param>
            <param name="valkey">Value to associate to this key</param>
            <returns>True if key is correctly set.</returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetFileType(System.String)">
            <summary>
            Get the human-readable file type of this extension
            </summary>
            <param name="fileExtension"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Utils.WinRegistry.GetAssociatedProgram(System.String)">
            <summary>
            Get the associated program
            </summary>
            <param name="fileExtension">File extension (ie: .doc)</param>
            <returns></returns>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredComplex">
            <summary>
            Rewrites the file area 3 times with 0xFF, 0x00, random bytes
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredComplex.#ctor">
            <summary>
            Shred complex constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredComplex.Name">
            <summary>
            Shred Method Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredComplex.Id">
            <summary>
            Shred Enum ID
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredComplex.Description">
            <summary>
            Shred complex description
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.SecurityConstants">
            <summary>
            Defines the external methods of the CryptoAPI and SCHANNEL API.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.SecurityConstants.#ctor">
            <summary>
            Defeat instantiation of this class.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.SupportedHashAlgoFactory">
            <summary>
            Supported Hash Algorithm Create.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgoFactory.FromName(System.String)">
            <summary>
            Get SupportedHash Algo from Name
            </summary>
            <param name="xName">The name of the hash algorithm</param>
            <returns>The SupportedHashAlgo with the given name</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgoFactory.FromId(System.Int32)">
            <summary>
            Get SupportedHash Algo from Name
            </summary>
            <param name="algoId">The name of the hash algorithm</param>
            <returns>The SupportedHashAlgo with the given ID</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgoFactory.GetAlgo(LLCryptoLib.Hash.AvailableHash)">
            <summary>
            Get the HashAlgorithm from an AvailableHash constant
            </summary>
            <param name="hashAlgo">An AvailableHash constant</param>
            <returns>The SupportedHashAlgo structure</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.Snefru2Parameters">
            <summary>A class that contains the parameters necessary to initialize a Snefru2 algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Snefru2Parameters.#ctor(System.Int16,System.Int16)">
            <summary>Initializes a new instance of the Snefru2Paramters class.</summary>
            <param name="passes">How many transformation passes to do.</param>
            <param name="length">The bit length of the final hash.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Snefru2Parameters.GetParameters(LLCryptoLib.Hash.Snefru2Standard)">
            <summary>Retrieves a standard set of Snefru2 parameters.</summary>
            <param name="standard">The name of the standard parameter set to retrieve.</param>
            <returns>The Snefru2 Parameters for the given standard.</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.Snefru2Parameters.Passes">
            <summary>Gets or sets the number of passes.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.Snefru2Parameters.Length">
            <summary>Gets or sets the bit length.</summary>
        </member>
        <member name="T:LLCryptoLib.CallbackEntry">
            <summary>
            Delegate to be used in long computing opertions
            to get a counter on operation status.
            p is the value returned.
            <seealso cref="T:LLCryptoLib.CallbackPoint"/>
            </summary>
            <code>
            //0. Update counter is a method with signature FeedbackExample(int p)
            CallbackEntry cbp = new CallbackEntry(FeedbackExample.UpdateCounter);
            </code>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider">
            <summary>
            Accesses the unmanaged version of the <see cref="T:System.Security.Cryptography.Rijndael"/> algorithm. This class cannot be inherited.
            </summary>
            <remarks>
            This class will use the unmanaged implementation of the Rijndael algorithm, when possible. If the unmanaged Rijndael algorithm is not available, it will fall back to the <see cref="T:System.Security.Cryptography.RijndaelManaged"/> implementation.
            </remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The AES cryptographic service provider could not be acquired.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider"/> class.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider"/> class.
            </summary>
            <param name="forceUnmanaged">Forces the class to use the unmanaged AES implementation. An exception will be thrown if this is impossible.</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while acquiring the AES CSP.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.Finalize">
            <summary>
            Releases all unmanaged resources.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.Dispose(System.Boolean)">
            <summary>
            Releases all unmanaged resources.
            </summary>
            <param name="disposing"><b>true</b> to release both managed and unmanaged resources; <b>false</b> to release only unmanaged resources.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.GenerateIV">
            <summary>
            Generates a random initialization vector (IV) to be used for the algorithm.
            </summary>
            <remarks>Use this method to generate a random IV when none is specified.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.GenerateKey">
            <summary>
            Generates a random Key to be used for the algorithm.
            </summary>
            <remarks>Use this method to generate a random key when none is specified.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates a symmetric <see cref="T:System.Security.Cryptography.Rijndael"/> decryptor object with the specified <see cref="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.Key"/> and initialization vector (<see cref="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.IV"/>).
            </summary>
            <param name="rgbKey">The secret key to be used for the symmetric algorithm.</param>
            <param name="rgbIV">The IV to be used for the symmetric algorithm.</param>
            <returns>A symmetric Rijndael decryptor object.</returns>
            <remarks>This method decrypts an encrypted message created using the <see cref="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])"/> overload with the same signature.</remarks>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while creating the decryptor.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates a symmetric <see cref="T:System.Security.Cryptography.Rijndael"/> encryptor object with the specified <see cref="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.Key"/> and initialization vector (<see cref="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.IV"/>).
            </summary>
            <param name="rgbKey">The secret key to be used for the symmetric algorithm.</param>
            <param name="rgbIV">The IV to be used for the symmetric algorithm.</param>
            <returns>A symmetric Rijndael encryptor object.</returns>
            <remarks>Use the <see cref="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])"/> overload with the same signature to decrypt the result of this method.</remarks>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while creating the encryptor.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.BlockSize">
            <summary>
            Gets or sets the block size of the cryptographic operation in bits.
            </summary>
            <value>The block size in bits.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The block size is invalid.</exception>
            <remarks>The block size is the basic unit of data that can be encrypted or decrypted in one operation. Messages longer than the block size are handled as successive blocks; messages shorter than the block size must be padded with extra bits to reach the size of a block. Valid block sizes are determined by the symmetric algorithm used.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.FeedbackSize">
            <summary>
            Gets or sets the feedback size of the cryptographic operation in bits.
            </summary>
            <value>The feedback size in bits.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The feedback size is larger than the block size.</exception>
            <remarks>The feedback size determines the amount of data that is fed back to successive encryption or decryption operations. The feedback size cannot be greater than the block size.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.IV">
            <summary>
            Gets or sets the initialization vector (IV) for the symmetric algorithm.
            </summary>
            <value>The initialization vector.</value>
            <exception cref="T:System.ArgumentNullException">An attempt is made to set the IV to a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An attempt is made to set the IV to an invalid size.</exception>
            <remarks>If this property is a null reference (<b>Nothing</b> in Visual Basic) when it is used, <see cref="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.GenerateIV"/> is called to create a new random value.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.Key">
            <summary>
            Gets or sets the secret key for the symmetric algorithm.
            </summary>
            <value>The secret key to be used for the symmetric algorithm.</value>
            <exception cref="T:System.ArgumentNullException">An attempt is made to set the key to a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <remarks>
            <p>The secret key is used both for encryption and for decryption. For a symmetric algorithm to be secure, the secret key must be known only to the sender and the receiver. The valid key sizes are specified by the particular symmetric algorithm implementation and are listed in <see cref="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.LegalKeySizes"/>.</p>
            <p>If this property is a null reference (<b>Nothing</b> in Visual Basic) when it is used, <see cref="M:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.GenerateKey"/> is called to create a new random value.</p>
            </remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.KeySize">
            <summary>
            Gets or sets the size of the secret key used by the symmetric algorithm in bits.
            </summary>
            <value>The size of the secret key used by the symmetric algorithm.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The key size is not valid.</exception>
            <remarks>The valid key sizes are specified by the particular symmetric algorithm implementation and are listed in <see cref="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.LegalKeySizes"/>.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.LegalBlockSizes">
            <summary>
            Gets the block sizes that are supported by the symmetric algorithm.
            </summary>
            <value>An array containing the block sizes supported by the algorithm.</value>
            <remarks>Only block sizes that match an entry in this array are supported by the symmetric algorithm.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.LegalKeySizes">
            <summary>
            Gets the key sizes that are supported by the symmetric algorithm.
            </summary>
            <value>An array containing the key sizes supported by the algorithm.</value>
            <remarks>Only key sizes that match an entry in this array are supported by the symmetric algorithm.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.Mode">
            <summary>
            Gets or sets the mode for operation of the symmetric algorithm.
            </summary>
            <value>The mode for operation of the symmetric algorithm.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The cipher mode is not one of the CipherMode values.</exception>
            <remarks>See CipherMode for a description of specific modes.</remarks>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RijndaelCryptoServiceProvider.Padding">
            <summary>
            Gets or sets the padding mode used in the symmetric algorithm.
            </summary>
            <value>The padding mode used in the symmetric algorithm.</value>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The padding mode is not one of the PaddingMode values.</exception>
            <remarks>Most plain text messages do not consist of a number of bytes that completely fill blocks. Often, there are not enough bytes to fill the last block. When this happens, a padding string is added to the text. For example, if the block length is 64 bits and the last block contains only 40 bits, 24 bits of padding are added. See <see cref="T:System.Security.Cryptography.PaddingMode"/> for a description of specific modes.</remarks>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform">
            <summary>
            Represents an ARCFour managed ICryptoTransform.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform"/> class.
            </summary>
            <param name="key">The key used to initialize the RC4 state.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inputOffset"/>, <paramref name="inputCount"/> or <paramref name="outputOffset"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
            <exception cref="T:System.ObjectDisposedException">The object has been disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="inputBuffer"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inputOffset"/> or <paramref name="inputCount"/> is invalid.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.Dispose">
            <summary>
            Disposes of the cryptographic parameters.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.Finalize">
            <summary>
            Finalizes the object.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
            <value>This property returns <b>true</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
            <value>This property returns <b>true</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.InputBlockSize">
            <summary>
            Gets the input block size.
            </summary>
            <value>This property returns 1.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Cryptography.RC4UnmanagedTransform.OutputBlockSize">
            <summary>
            Gets the output block size.
            </summary>
            <value>This property returns 1.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider">
            <summary>
            Computes the <see cref="T:LLCryptoLib.Security.Cryptography.MD2"/> hash for the input data using the implementation provided by the cryptographic service provider (CSP).
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.MD2">
            <summary>
            Represents the abstract class from which all implementations of the MD2 hash algorithm inherit.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:LLCryptoLib.Security.Cryptography.MD2"/>.
            </summary>
            <remarks>You cannot create an instance of an abstract class. Application code will create a new instance of a derived class.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2.Create">
            <summary>
            Creates an instance of the default implementation of the <see cref="T:LLCryptoLib.Security.Cryptography.MD2"/> hash algorithm.
            </summary>
            <returns>A new instance of the MD2 hash algorithm.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2.Create(System.String)">
            <summary>
            Creates an instance of the specified implementation of the <see cref="T:LLCryptoLib.Security.Cryptography.MD2"/> hash algorithm.
            </summary>
            <param name="hashName">The name of the specific implementation of MD2 to use.</param>
            <returns>A new instance of the specified implementation of MD2.</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurs while initializing the hash.</exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider"/> class. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider.Initialize">
            <summary>
            Initializes an instance of <see cref="T:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The MD2CryptoServiceProvider instance has been disposed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Routes data written to the object into the <see cref="T:LLCryptoLib.Security.Cryptography.MD2"/> hash algorithm for computing the hash.
            </summary>
            <param name="array">The array of data bytes.</param>
            <param name="ibStart">The offset into the byte array from which to begin using data.</param>
            <param name="cbSize">The number of bytes in the array to use as data.</param>
            <exception cref="T:System.ObjectDisposedException">The MD2CryptoServiceProvider instance has been disposed.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The data could not be hashed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider.HashFinal">
            <summary>
            Returns the computed <see cref="T:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider"/> hash as an array of bytes after all data has been written to the object.
            </summary>
            <returns>The computed hash value.</returns>
            <exception cref="T:System.ObjectDisposedException">The MD2CryptoServiceProvider instance has been disposed.</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The data could not be hashed.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider"/> and optionally releases the managed resources.
            </summary>
            <param name="disposing"><b>true</b> to release both managed and unmanaged resources; <b>false</b> to release only unmanaged resources.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Cryptography.MD2CryptoServiceProvider.Finalize">
            <summary>
            Finalizes the MD2CryptoServiceProvider.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateException">
            <summary>
            The exception that is thrown when a certificate error is detected.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateException.#ctor">
            <summary>
            Initializes a new instance of the CertificateException class with default properties.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the CertificateException class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the CertificateException class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="inner">The exception that is the cause of the current exception. If the inner parameter is not a null reference (<b>Nothing</b> in Visual Basic), the current exception is raised in a catch block that handles the inner exception.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.CertificateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the CertificateException class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:LLCryptoLib.Hash.Snefru2">
            <summary>Computes the Snefru2 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Snefru2.#ctor(LLCryptoLib.Hash.Snefru2Parameters)">
            <summary>Initializes a new instance of the Snefru2 class.</summary>
            <param name="param">The parameters to utilize in the Snefru calculation.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Snefru2.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Snefru2.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Snefru2.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.FNVParameters">
            <summary>A class that contains the parameters necessary to initialize a FNV algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FNVParameters.#ctor(System.Int32,System.Int64,System.Int64,LLCryptoLib.Hash.FNVAlgorithmType)">
            <summary>Initializes a new instance of the FNVParamters class.</summary>
            <param name="order">The order of the FNV (e.g., how many bits).</param>
            <param name="prime">The prime number to use in the FNV calculations.</param>
            <param name="offsetBasis">The offset basis of the FNV.</param>
            <param name="type">The FNV algorithm variation.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.FNVParameters.GetParameters(LLCryptoLib.Hash.FNVStandard)">
            <summary>Retrieves a standard set of FNV parameters.</summary>
            <param name="standard">The name of the standard parameter set to retrieve.</param>
            <returns>The FNV Parameters for the given standard.</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.FNVParameters.Order">
            <summary>Gets or sets the order of the FNV (e.g., how many bits).</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.FNVParameters.Prime">
            <summary>Gets or sets the prime number to use in the FNV calculations.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.FNVParameters.OffsetBasis">
            <summary>Gets or sets the offset basis of the FNV.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.FNVParameters.Type">
            <summary>Gets or sets the FNV algorithm variation.</summary>
        </member>
        <member name="T:LLCryptoLib.Hash.FCS32">
            <summary>Computes the FCS32 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS32.#ctor">
            <summary>Initializes a new instance of the FCS32 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS32.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.FCS32.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextEncryptionUtils">
            <summary>
            Utility for text encryption
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextEncryptionUtils.MemoryToBase64String(System.IO.MemoryStream)">
            <summary>
            Convert a MemoryStream to a Base64 representation of bytes
            </summary>
            <param name="instream">Memory Stream containing bytes</param>
            <returns>Base 64 representation of bytes</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextEncryptionUtils.IsBase64(System.String)">
            <summary>
            Returns true if the input string CAN BE a Base64 string.
            Since there is not an exact way to determine if a string is a Base64 string
            and not simple text, this method returns true if the string is 'compliant'
            with Base64, and so it can be a result of a Base64 encoding.
            </summary>
            <param name="toCheck">A string to check for Base64</param>
            <returns>Returns true if the input string CAN BE a Base64 string</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextEncryptionUtils.MemoryToString(System.IO.MemoryStream)">
            <summary>
            Convert a MemoryStream to a clear text string
            </summary>
            <param name="instream">Memory Stream containing text</param>
            <returns>Clear text</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextEncryptionUtils.Base64StringToBytes(System.String)">
            <summary>
            Convert a Base64 string to its bytes
            </summary>
            <param name="inBase">Base64 inputString</param>
            <returns>Bytes in Base64 string</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextEncryptionUtils.BytesToBase64String(System.Byte[])">
            <summary>
            Convert an array of bytes to a Base64 representation of bytes
            </summary>
            <param name="inBytes">Input array of bytes</param>
            <returns>Base 64 representation of bytes</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextEncryptionUtils.StringToBytes(System.String)">
            <summary>
            Convert a string into an array of bytes
            </summary>
            <param name="instr">String to convert</param>
            <returns>Array of bytes</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextEncryptionUtils.BytesToString(System.Byte[])">
            <summary>
            Convert an array of bytes into an hexadecimal string
            </summary>
            <param name="arrBytes">Array of bytes to convert</param>
            <returns>Hexadecimal String</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextDES">
            <summary>
            DES algorithm for text.
            When encrypting, the algorithm is applied to the byte encoding of the input text, see <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.StringToBytes(System.String)"/>,
            then, after encryption, rendered to a Base64 string with <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.MemoryToBase64String(System.IO.MemoryStream)"/>.
            When decrypting, the text is first trasformed into a byte sequence with <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.Base64StringToBytes(System.String)"/>,
            then decrypted, then the resulting bytes are transformed to a string with <see cref="M:LLCryptoLib.Crypto.TextEncryptionUtils.MemoryToString(System.IO.MemoryStream)"/>
            </summary>
            <example>
            <code>
            TextAlgorithmParameters parms = new TextAlgorithmParameters("llcryptopassword");
            TextCrypter textEncrypter = new TextCrypter(new TextDES(parms));
            encrypted = textEncrypter.Base64EncryptDecrypt(origString, true);
            Console.WriteLine("Encrypted string: " + encrypted);
            decrypted = textEncrypter.Base64EncryptDecrypt(encrypted, false);
            Console.WriteLine("Decrypted string: " + decrypted);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextDES.#ctor(LLCryptoLib.Crypto.TextAlgorithmParameters)">
            <summary>
            DES class
            </summary>
            <param name="p">Parametri (key and shift)</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextDES.Code(System.String)">
            <summary>
            Code using DES algoritml
            </summary>
            <param name="txt">String text to code (text must be UTF8 compatible)</param>
            <returns>Base64 representation of text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextDES.Decode(System.String)">
            <summary>
            Decode using DES algorithm
            </summary>
            <param name="txt"></param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextDES.EncryptData(System.Byte[],System.Boolean)">
            <summary>
            Encrypts/Decrypts using DES algorithm
            </summary>
            <param name="txt">Bytes to crypt/decrypt in bytes</param>
            <param name="isCrypting">If true, crypt, else decrypt</param>
            <returns></returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.StreamAlgorithmFactory">
            <summary>
            A StreamAlgorithmFactory is a factory class to create
            IStreamAlgorithm objects based on their description or IDs.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAlgorithmFactory.Create(System.String)">
            <summary>
            Create an IStreamAlgoritm object from its description.
            Description must match the one defined in the StreamAlgorithm
            Description field.
            </summary>
            <param name="description">The description, as in StreamAlgorithm Description field</param>
            <returns>A newly created IStreamAlgorithm object. If 'description' is not found, then returns null.</returns>
            <see cref="T:LLCryptoLib.Crypto.StreamAlgorithm"/>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.Create("DES");
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAlgorithmFactory.Create(LLCryptoLib.Crypto.SupportedStreamAlgorithms)">
            <summary>
            Create an IStreamAlgoritm object from its SupportedStreamAlgorithms id.
            </summary>
            <param name="ssa">SupportedStreamAlgorithms id</param>
            <returns>A newly created IStreamAlgorithm object</returns>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.Create(SupportedStreamAlgorithms.AES128);
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="M:LLCryptoLib.Crypto.StreamAlgorithmFactory.GetAlgos">
            <summary>
            Get all available stream algoritms.
            </summary>
            <returns>An array of all available algorithms</returns>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.DES64">
            <summary>
            Create a new StreamDES object
            </summary>
            <value>A DES object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.DES64;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.TripleDES">
            <summary>
            Create a new Stream3DES object
            </summary>
            <value>A 3DES object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.TripleDES;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.AES128">
            <summary>
            Create a new StreamAES object
            </summary>
            <value>A 128 bit AES-Rijndael object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.AES128;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.AES192">
            <summary>
            Create a new StreamAES192 object
            </summary>
            <value>A 192 bit AES-Rijndael object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.AES192;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.AES256">
            <summary>
            Create a new StreamAES256 object
            </summary>
            <value>A 256 bit AES-Rijndael object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.AES256;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.ArcFour">
            <summary>
            Create a new StreamARC4 object
            </summary>
            <value>A 128 bit ARC4 object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.ArcFour;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.ArcFour512">
            <summary>
            Create a new StreamARC4512 object
            </summary>
            <value>A 512 bit ARC4 object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.ARC4512;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.ArcFour1024">
            <summary>
            Create a new StreamARC41024 object
            </summary>
            <value>A 1024 bit ARC4 object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.ArcFour1024;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.ArcFour2048">
            <summary>
            Create a new StreamARC42048 object
            </summary>
            <value>A 2048 bit ARC4 object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.ArcFour2048;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.Blowfish">
            <summary>
            Create a new Blowfish object
            </summary>
            <value>A 128 bit Blowfish object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.Blowfish;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.Blowfish256">
            <summary>
            Create a new Blowfish object
            </summary>
            <value>A 256 bit Blowfish object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.Blowfish256;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="P:LLCryptoLib.Crypto.StreamAlgorithmFactory.Blowfish448">
            <summary>
            Create a new Blowfish object
            </summary>
            <value>A 256 bit Blowfish object</value>
            <example>
            Stream Encryption with DES
            <code>  
            // Set encryption algorithm
            IStreamAlgorithm encryptAlgo = StreamAlgorithmFactory.Blowfish448;
            StreamCrypter encrypter = new StreamCrypter(encryptAlgo);
            // Set symmetric password
            encrypter.GenerateKeys("littlelitesoftware");
            // Encrypt
            encrypter.EncryptDecrypt(rndFile.FullName, encryptedFile, true, null);
            Console.WriteLine("File encrypted into " + encryptedFile);
            </code>
            </example>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredNothing">
            <summary>
            No shred option. It deletes the file with OS delete.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredNothing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Shred.ShredNothing"/> class.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredNothing.Name">
            <summary>
            Shred Method Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredNothing.Id">
            <summary>
            Shred Enum ID
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredNothing.Description">
            <summary>
            Shredding description
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredGutmann">
            <summary>
            Rewrites the file area 35 times with 0x34, 0x12, 0x1B, 0x00, 0x55, 0xAA, 0x24, 0x92, 
            0x49, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 
            0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 
            0xFF, 0x24, 0x92, 0x49, 0xDB, 0x6D, 0xB6, 0x12, 
            0xFF, 0x82, 0x9A
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredGutmann.#ctor">
            <summary>
            Gutmann constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredGutmann.Name">
            <summary>
            Shred Method Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredGutmann.Id">
            <summary>
            Shred Enum ID
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredGutmann.Description">
            <summary>
            Return "Overwrite the file area following the Gutmann standard recommendations."
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.FNVStandard">
            <summary>Predefined standards for FNV algorithms.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVStandard.FNV0_32">
            <summary>A 32bit FNV-0 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVStandard.FNV0_64">
            <summary>A 64bit FNV-0 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVStandard.FNV1_32">
            <summary>A 32bit FNV-1 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVStandard.FNV1_64">
            <summary>A 64bit FNV-1 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVStandard.FNV1A_32">
            <summary>A 32bit FNV-1a algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.FNVStandard.FNV1A_64">
            <summary>A 64bit FNV-1a algorithm.</summary>
        </member>
        <member name="T:LLCryptoLib.Hash.EndianType">
            <summary>The order in which to store the bytes for integers.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.EndianType.LittleEndian">
            <summary>The Least Significant Byte is first.</summary>
        </member>
        <member name="F:LLCryptoLib.Hash.EndianType.BigEndian">
            <summary>The Most Significant Byte is first.</summary>
        </member>
        <member name="T:LLCryptoLib.Hash.AvailableHash">
            <summary>
            Available Hash Algorithms enumeration
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.FAKE">
            <summary>
            No Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.ADLER32">
            <summary>
            Adler 32 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.CRC32">
            <summary>
            CRC32 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.FCS16">
            <summary>
            FCS16 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.FCS32">
            <summary>
            FCS32 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.GOST">
            <summary>
             GOST Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.MD2">
            <summary>
            MD2 Hash
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.MD4">
            <summary>
            MD4 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.MD5">
            <summary>
            MD5 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.SHA1">
            <summary>
            SHA1 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.SHA224">
            <summary>
            SHA224 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.SHA256">
            <summary>
            SHA256 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.SHA384">
            <summary>
            SHA384 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.SHA512">
            <summary>
            SHA512 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.TIGER">
            <summary>
            TIGER Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.RIPEMD160">
            <summary>
            RIPEMD160 Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.HAVAL128">
            <summary>
            HAVAL 128 bits Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.HAVAL160">
            <summary>
            HAVAL 160 bits Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.HAVAL192">
            <summary>
            HAVAL 192 bits Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.HAVAL224">
            <summary>
            HAVAL 224 bits Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.HAVAL256">
            <summary>
            HAVAL 256 bits Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.HMACSHA1">
            <summary>
            HMACSHA1 Keyed Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.WHIRLPOOL">
            <summary>
            Whirlpool Hash Algorithm
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.GHASH323">
            <summary>
            GHash 32-3
            </summary>
        </member>
        <member name="F:LLCryptoLib.Hash.AvailableHash.GHASH325">
            <summary>
            GHash 32-5
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredMethods">
            <summary>
            ShredMethod is a struct describing the shredding methods and
            a factory of ShredMethod objects.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredMethods.Get(LLCryptoLib.Shred.AvailableShred)">
            <summary>
            Get a shred method
            </summary>
            <param name="shred">Enumeration shred methods</param>
            <returns>The shred method object</returns>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredMethods.FromString(System.String)">
            <summary>
            Return a shred method object from a string
            </summary>
            <param name="method">The method name as in GetSupportedMethods</param>
            <returns>A shred object</returns>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredMethods.GetSupportedMethods">
            <summary>
            Supported methods
            </summary>
            <returns>String array containing the supported methods</returns>
        </member>
        <member name="T:LLCryptoLib.Shred.AvailableShred">
            <summary>
            Available Shredding Methods
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.NOTHING">
            <summary>
            No Shred
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.SIMPLE">
            <summary>
            Single Overwrite Shred
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.COMPLEX">
            <summary>
            Complex Shred
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.RANDOM">
            <summary>
            Random Shred
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.HMGIS5ENH">
            <summary>
            HMG Infosec Standard 5 Enhanced
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.GERMAN">
            <summary>
            German VSITR Shred
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.DOD">
            <summary>
            Department Of Defence Shred
            </summary>
        </member>
        <member name="F:LLCryptoLib.Shred.AvailableShred.GUTMANN">
            <summary>
            Gutmann Shred
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.ProtectionType">
            <summary>
            Specifies the type of encryption method to use when protecting data.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.ProtectionType.LocalMachine">
            <summary>The encrypted data is associated with the local machine. Any user on the computer on which the data is encrypted can decrypt the data.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.ProtectionType.CurrentUser">
            <summary>The encrypted data is associated with the current user. Only a user with logon credentials matching those of the encrypter can decrypt the data.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.CryptoAlgorithm">
            <summary>
            Specifies the type of algorithm to be used when performing unmanaged cryptographic transformations.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoAlgorithm.Rijndael128">
            <summary>The Rijndael algorithm with a key size of 128 bits.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoAlgorithm.Rijndael192">
            <summary>The Rijndael algorithm with a key size of 192 bits.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoAlgorithm.Rijndael256">
            <summary>The Rijndael algorithm with a key size of 256 bits.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoAlgorithm.RC4">
            <summary>The RC4 algorithm.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.CryptoProvider">
            <summary>
            Specifies the type of CSP to be used when performing unmanaged cryptographic transformations.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoProvider.RsaFull">
            <summary>Microsoft's full RSA CSP.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoProvider.RsaAes">
            <summary>Microsoft's full RSA CSP that supports the AES.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.CryptoMethod">
            <summary>
            Specifies the type of transformation for a cryptographic operation.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoMethod.Encrypt">
            <summary>Encrypt the data.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.CryptoMethod.Decrypt">
            <summary>Decrypt the data.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Cryptography.PUBLICKEYSTRUC">
            <summary>
            The PUBLICKEYSTRUC structure, also known as the BLOBHEADER structure, indicates a key's BLOB type and the algorithm that the key uses. One of these structures is located at the beginning of the pbData member of every key BLOB.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.PUBLICKEYSTRUC.bType">
            <summary>Key BLOB type. The only BLOB types currently defined are PUBLICKEYBLOB, PRIVATEKEYBLOB, SIMPLEBLOB, and PLAINTEXTBLOB. Other key BLOB types will be defined as needed. </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.PUBLICKEYSTRUC.bVersion">
            <summary>Version number of the key BLOB format. This currently must always have a value of CUR_BLOB_VERSION (0x02).</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.PUBLICKEYSTRUC.reserved">
            <summary>WORD reserved for future use. Must be set to zero.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Cryptography.PUBLICKEYSTRUC.aiKeyAlg">
            <summary>Algorithm identifier for the key contained by the key BLOB. Some examples are CALG_RSA_SIGN, CALG_RSA_KEYX, CALG_RC2, and CALG_RC4.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.HashType">
            <summary>
            Defines the different hash type values.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.HashType.SHA1">
            <summary>The certificate will be hashed using the SHA1 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.HashType.MD5">
            <summary>The certificate will be hashed using the MD5 algorithm.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.HashType.Default">
            <summary>The certificate will be hashed using the default hashing algorithm.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.KeyUsage">
            <summary>
            Defines the different key usage values.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeyUsage.DataEncipherment">
            <summary>The key can be used for data encipherment.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeyUsage.DigitalSignature">
            <summary>The key can be used to sign data.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeyUsage.KeyAgreement">
            <summary>The key can be used in key agreement algorithms.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeyUsage.KeyCertSign">
            <summary>The key can be used to sign certificates.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeyUsage.KeyEncipherment">
            <summary>The key can be used for key encipherment.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeyUsage.NonRepudiation">
            <summary>The key can be used for electronic non-repudiation.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeyUsage.CrlSign">
            <summary>The key can be used to sign certificate revocation lists.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.AuthType">
            <summary>
            Defines the different authentication type values.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.AuthType.Client">
            <summary>The certificate is a client certificate.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.AuthType.Server">
            <summary>The certificate is a server certificate.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateStatus">
            <summary>
            Defines the different certificate status values.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.ValidCertificate">
            <summary>The certificate is valid.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.Expired">
            <summary>A required certificate is not within its validity period.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.InvalidBasicConstraints">
            <summary>The certificate's basic constraints are invalid or missing.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.InvalidChain">
            <summary>A chain of certificates was not correctly created.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.InvalidNesting">
            <summary>The validity periods of the certification chain do not nest correctly.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.InvalidPurpose">
            <summary>A certificate is being used for a non permitted purpose.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.InvalidRole">
            <summary>A certificate that can only be used as an end-entity is being used as a CA or visa versa.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.InvalidSignature">
            <summary>The signature of the certificate cannot be verified.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.NoCNMatch">
            <summary>The certificate's CN name does not match the passed value.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.ParentRevoked">
            <summary>A certificate in the chain has been explicitly revoked by its issuer.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.RevocationFailure">
            <summary>The revocation process could not continue. The certificates could not be checked.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.RevocationServerOffline">
            <summary>Since the revocation server was offline, the called function was not able to complete the revocation check.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.Revoked">
            <summary>The certificate or signature has been revoked.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.UntrustedRoot">
            <summary>A certification chain processed correctly but terminated in a root certificate not trusted by the trust provider.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.UntrustedTestRoot">
            <summary>The root certificate is a testing certificate and policy settings disallow test certificates.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.WrongUsage">
            <summary>The certificate is not valid for the requested usage.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStatus.OtherError">
            <summary>The certificate is invalid.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateStoreType">
            <summary>
            Defines the different certificate store values.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStoreType.SerializedStore">
            <summary>The certificate store should be saved as a serializes store.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateStoreType.Pkcs7Message">
            <summary>The certificate store should be saved as a signed PKCS7 message.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.CertificateChainOptions">
            <summary>
            Defines additional options for building a certificate chain.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.Default">
            <summary>The default chain options</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.RevocationCheckEndCert">
            <summary>Revocation checking is done on the end certificate and only the end certificate.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.RevocationCheckChain">
            <summary>Revocation checking is done on all of the certificates in every chain.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.RevocationCheckChainExcludeRoot">
            <summary>Revocation checking in done on all certificates in all of the chains except the root certificate.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.RevocationCacheEndCert">
            <summary>When this flag is set, the end certificate is cached, which might speed up the chain-building process. By default, the end certificate is not cached and it would need to be verified each time a chain is built for it.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.RevocationCheckCacheOnly">
            <summary>Revocation checking only accesses cached URLs and does not hit the wire to do any revocation URL retrieval. Supported on Windows Me, Windows 2000 and later.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.CacheOnlyUrlRetrieval">
            <summary>Uses only cached URLs in building a certificate chain. The Internet and Intranet are not searched for URL-based objects. Note, not applicable to revocation checking. Set CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY to use only cached URLs for revocation checking.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.DisablePass1QualityFiltering">
            <summary>For performance reasons, the second pass of chain building only considers potential chain paths that have quality greater than or equal to the highest quality determined during the first pass. The first pass only considers valid signature, complete chain and trusted roots to calculate chain quality. This flag can be set to disable this optimization and consider all potential chain paths during the second pass.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.ReturnLowerQualityContexts">
            <summary>The default is to return only the highest quality chain path. Setting this flag will return the lower quality chains. These are returned in the chain context's cLowerQualityChainContext and rgpLowerQualityChainContext fields.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.CertificateChainOptions.DisableAuthRootAutoUpdate">
            <summary>Setting this flag inhibits the auto update of third party roots from the Windows Update Web Server.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.VerificationFlags">
            <summary>
            Defines the different verificateion flags values.
            </summary>
            <remarks>
            You can specify more VerificationFlags at once by combining them with the OR operator.
            </remarks>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.None">
            <summary>No flags.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreTimeNotValid">
            <summary>Ignore an invalid time.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreCtlTimeNotValid">
            <summary>Ignore an invalid time of the certificate trust list.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreTimeNotNested">
            <summary>Ignore an invalid time nesting.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreInvalidBasicContraints">
            <summary>Ignore invalid basic contraints.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreAllTimeChecks">
            <summary>Ignore all time checks.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.AllowUnknownCA">
            <summary>Allow an unknown certificate authority.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreWrongUsage">
            <summary>Ignore the wrong usage of a certificate.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreInvalidName">
            <summary>Ignore an invalid name.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreInvalidPolicy">
            <summary>Ignore an invalid policy.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreEndRevUnknown">
            <summary>Ignore an unknown revocation status of the end certificate.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreSignerRevUnknown">
            <summary>Ignore an unknown revocation status of the signer certificate.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreCARevUnknown">
            <summary>Ignore an unknown revocation status of the certificate authority.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreRootRevUnknown">
            <summary>Ignore an unknown revocation status of the root certificate.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.IgnoreAllRevUnknown">
            <summary>Ignore an unknown revocation status of any of the certificates.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.AllowTestroot">
            <summary>Allow a test root.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.VerificationFlags.TrustTestroot">
            <summary>Trust a test root.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.StoreLocation">
            <summary>
            Specifies the location of the X.509 certificate store.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.CurrentService">
            <summary>The certificate store for the current service.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.CurrentUser">
            <summary>The certificate store for the currently logged-on user.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.CurrentUserGroupPolicy">
            <summary>The certificate store for the currently logged-on group.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.LocalMachine">
            <summary>The certificate store for the local computer.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.LocalMachineEnterprise">
            <summary>The certificate store for the local machine enterprise downloaded from a network setting.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.LocalMachineGroupPolicy">
            <summary>The certificate store for the local machine group policy downloaded from a network setting.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.Services">
            <summary>The certificate store for a specified service account; for example, an Alerter or the Event Log.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.Unknown">
            <summary>The location is unknown.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.StoreLocation.Users">
            <summary>The certificate store for the users group of this computer.</summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.NameAttribute">
            <summary>
            Defines a structure that represents one attribute of a relative distinguished name.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.NameAttribute.#ctor(System.String,System.String)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/> instance.
            </summary>
            <param name="oid">The object identifier of the attribute.</param>
            <param name="val">The decoded value of the attribute.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.NameAttribute.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/>.
            </summary>
            <param name="obj">The Object to compare with the current Object. </param>
            <returns><b>true</b> if the specified Object is equal to the current NameAttribute; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.NameAttribute.GetHashCode">
            <summary>
            Serves as a hash function for a <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/> type, suitable for use in hashing algorithms and data structures like a hash table.
            </summary>
            <returns>A hash code for the current Object.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.NameAttribute.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/>.
            </summary>
            <returns>A String that represents the current NameAttribute.</returns>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.NameAttribute.ObjectID">
            <summary>
            The object identifier of the attribute.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.NameAttribute.Value">
            <summary>
            The value of the attribute.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.Extension">
            <summary>
            Represents an encoded certificate extension. 
            </summary>
            <remarks>These extensions can be decoded with the Certificate.DecodeExtension() method.</remarks>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.Extension.#ctor(System.String,System.Boolean,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.Extension"/> class.
            </summary>
            <param name="oid">The object identifier of the extension.</param>
            <param name="critical"><b>true</b> if it is a critical extension, <b>false</b> otherwise.</param>
            <param name="val">A byte array that contains the encoded extension.</param>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Extension.ObjectID">
            <summary>
            The object identifier of the extension.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Extension.Critical">
            <summary>
            <b>true</b> if it is a critical extension, <b>false</b> otherwise.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.Extension.EncodedValue">
            <summary>
            A byte array that contains the encoded extension.
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.KeysetLocation">
            <summary>
            Defines the different keyset locations.
            </summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeysetLocation.Default">
            <summary>The private keys are stored in the default location.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeysetLocation.LocalMachine">
            <summary>The private keys are stored under local machine and not the current user.</summary>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.KeysetLocation.CurrentUser">
            <summary>The private keys are stored under the current user and not the local machine even if the PFX BLOB specifies they should go into local machine.</summary>
        </member>
        <member name="T:LLCryptoLib.PasswordComplexityIndex">
            <summary>
            This class can evaluate a string to return an index
            between 0 (minimum) and 40 (maximum) that indicates
            the password strength.
            </summary>
        </member>
        <member name="M:LLCryptoLib.PasswordComplexityIndex.#ctor">
            <summary>
            The password complexity index.
            </summary>
            <see href="http://www.mandylionlabs.com/index15.htm"/>
        </member>
        <member name="M:LLCryptoLib.PasswordComplexityIndex.Evaluate(System.String)">
            <summary>
            Evaluate the complexity index of the given password/passphrase
            </summary>
            <param name="passphrase">a given password string</param>
        </member>
        <member name="P:LLCryptoLib.PasswordComplexityIndex.Complexity">
            <summary>
            The complexity of this password as total requested workload in floating points
            </summary>
        </member>
        <member name="P:LLCryptoLib.PasswordComplexityIndex.HoursToCrack">
            <summary>
            The estimated hours to crack the password on a computer capable of 2*2^33 trials per hour
            </summary>
        </member>
        <member name="P:LLCryptoLib.PasswordComplexityIndex.ComplexityProxy">
            <summary>
            It is ln(Complexity), with a value between 0 (minimum) and 40 (maximum)
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.Tiger">
            <summary>Computes the Tiger hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Tiger.#ctor">
            <summary>Initializes a new instance of the Tiger class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Tiger.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.Tiger.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.Tiger.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The final block of data to process.</param>
            <param name="inputOffset">Where to start in the array.</param>
            <param name="inputCount">How many bytes should be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.RIPEMD160">
            <summary>Computes the RIPEMD160 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD160.#ctor">
            <summary>Initializes a new instance of the RIPEMD160 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD160.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD160.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.RIPEMD160.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.TextCrypter">
            <summary>
            A TextCrypter object is used to encrypt or decrypt strings.
            </summary>
            <example><code>
            
             // TextROT13 TEXT TRANSFORMATION
             TextAlgorithmParameters parms = new TextAlgorithmParameters(3);
             TextCrypter textEncrypter = TextCrypterFactory.Create(SupportedTextAlgorithms.ROT13,parms);
             string encrypted = textEncrypter.TextEncryptDecrypt(origString, true);
             Console.WriteLine("Encrypted string: " + encrypted);
             string decrypted = textEncrypter.TextEncryptDecrypt(encrypted, false);
             Console.WriteLine("Decrypted string: " + decrypted);
             Console.WriteLine(); 
            </code></example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCrypter.#ctor(LLCryptoLib.Crypto.TextAlgorithm)">
            <summary>
            Constructor
            </summary>
            <param name="algorithm">Encryption or decryption algorithm</param>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCrypter.TextEncryptDecrypt(System.String,System.Boolean)">
            <summary>
            Apply encryption algorithm to text. Output is a text string.
            </summary>
            <param name="text">Text to encode/decode</param>
            <param name="coding">If true, code, else decode</param>
            <returns>Encrypted/Decrypted Text</returns>
            <example><code>
            
                    // TextROT13 TEXT TRANSFORMATION
                   TextAlgorithmParameters parms = new TextAlgorithmParameters(3);
                   TextCrypter textEncrypter = TextCrypterFactory.Create(SupportedTextAlgorithms.ROT13,parms);
                   string encrypted = textEncrypter.TextEncryptDecrypt(origString, true);
                   Console.WriteLine("Encrypted string: " + encrypted);
                   string decrypted = textEncrypter.TextEncryptDecrypt(encrypted, false);
                   Console.WriteLine("Decrypted string: " + decrypted);
            	   Console.WriteLine(); 
            
            </code></example>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCrypter.Base64EncryptDecrypt(System.String,System.Boolean)">
            <summary>
            Apply encryption algorithm to text. Output is a Base64 text string.
            </summary>
            <param name="text">Text to encode/decode</param>
            <param name="coding">If true, code, else decode</param>
            <returns>Encrypted/Decrypted Text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCrypter.HexEncryptDecrypt(System.String,System.Boolean,LLCryptoLib.HexStyle)">
            <summary>
            Apply encryption algorithm to text. Output is in hex numbers
            </summary>
            <param name="text">Text to encode/decode</param>
            <param name="coding">If true, code, else decode</param>
            <param name="style">Hexadecimal style to use</param>
            <returns>Encrypted/Decrypted Text</returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.TextCrypter.ToString">
            <summary>
            The description of algorithm and its paramters
            </summary>
            <returns>The description of algorithm and its paramters</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.SupportedTextAlgorithms">
            <summary>
            Supported Text Encryption Algorithms
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedTextAlgorithms.ROT13">
            <summary>
            TextROT13 (Caesar)
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedTextAlgorithms.POLYALPHABETIC">
            <summary>
            Polyalphabetic
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedTextAlgorithms.PSEUDODES">
            <summary>
            PseudoDES
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedTextAlgorithms.PLAYFAIR">
            <summary>
            TextPlayfair
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedTextAlgorithms.RIJNDAEL">
            <summary>
            Rijndael or AES
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedTextAlgorithms.DES">
            <summary>
            DES
            </summary>
        </member>
        <member name="F:LLCryptoLib.Crypto.SupportedTextAlgorithms.TRIPLEDES">
            <summary>
            TripleDES or 3DES
            </summary>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredDOD">
            <summary>
            Rewrites the file area 7 times with 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xF6 bytes.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredDOD.#ctor">
            <summary>
            Shred DOD (Department of Defense) constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredDOD.Name">
            <summary>
            Shred Method Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredDOD.Id">
            <summary>
            Shred Enum ID
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredDOD.Description">
            <summary>
            Returns "Three iterations completely overwrite the file area six times. Each iteration makes two write-passes over the entire drive: the first pass inscribes ONEs (1) and the next pass inscribes ZEROes (0). After the third iteration, a seventh pass writes the government-designated code 246 across the drive (in hex 0xF6)"
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.SupportedHashAlgorithms">
            <summary>
            A class to summarize the library supported Hash Algorithm
            </summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgorithms.GetFastHashAlgorithms">
            <summary>
            List of fast hash algortihms
            </summary>
            <returns>An array of string names of the algorithms that are supposed to perform fast.</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgorithms.GetNoKeyedHashAlgorithms">
            <summary>
            List of all hash algorithms without Keyed ones
            </summary>
            <returns>All hash algorithms except the ones that needs a key (Keyed)</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgorithms.GetHashAlgorithms">
            <summary>
            List of all available hash algorithms
            </summary>
            <returns>An array of strings containing all the names of the supported hash algorithms</returns>
        </member>
        <member name="M:LLCryptoLib.Hash.SupportedHashAlgorithms.GetHashAlgorithmsWithNone">
            <summary>
            List of all available hash algorithm, plus "None" for no algorithm
            </summary>
            <returns>An array of strings containing all the names of the supported hash algorithms, plus a "None" string to indicate that no algorithm is wanted.</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.SupportedHashAlgorithms.Count">
            <summary>
            Number of supported hash algorithms
            </summary>
        </member>
        <member name="T:LLCryptoLib.Hash.HAVALParameters">
            <summary>A class that contains the parameters necessary to initialize a HAVAL algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.HAVALParameters.#ctor(System.Int16,System.Int16)">
            <summary>Initializes a new instance of the HAVALParamters class.</summary>
            <param name="passes">How many transformation passes to do.</param>
            <param name="length">The bit length of the final hash.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.HAVALParameters.GetParameters(LLCryptoLib.Hash.HAVALStandard)">
            <summary>Retrieves a standard set of HAVAL parameters.</summary>
            <param name="standard">The name of the standard parameter set to retrieve.</param>
            <returns>The HAVAL Parameters for the given standard.</returns>
        </member>
        <member name="P:LLCryptoLib.Hash.HAVALParameters.Passes">
            <summary>Gets or sets the number of passes.</summary>
        </member>
        <member name="P:LLCryptoLib.Hash.HAVALParameters.Length">
            <summary>Gets or sets the bit length.</summary>
        </member>
        <member name="T:LLCryptoLib.Hash.GHash">
            <summary>Computes the GHash hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.GHash.#ctor(LLCryptoLib.Hash.GHashParameters)">
            <summary>
            Initializes a new instance of the <see cref="T:GHash"/> class.
            </summary>
            <param name="param">The Ghash parameters</param>
        </member>
        <member name="M:LLCryptoLib.Hash.GHash.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.GHash.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Drives the hashing function.</summary>
            <param name="array">The array containing the data.</param>
            <param name="ibStart">The position in the array to begin reading from.</param>
            <param name="cbSize">How many bytes in the array to read.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.GHash.HashFinal">
            <summary>Performs any final activities required by the hash algorithm.</summary>
            <returns>The final hash value.</returns>
        </member>
        <member name="T:LLCryptoLib.Utils.ClipboardUtils">
            <summary>
            Clipboard management
            </summary>
        </member>
        <member name="M:LLCryptoLib.Utils.ClipboardUtils.Copy(System.String)">
            <summary>
            Copy text string to clipboard
            </summary>
            <param name="what">The string to be copied into the clipboard</param>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">This method is not supported in Mono</exception>
        </member>
        <member name="M:LLCryptoLib.Utils.ClipboardUtils.CanPaste">
            <summary>
            Return true if the clipboard contains something pasteable as a string
            </summary>
            <returns>true if the clipboard contains something pasteable</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">This method is not supported in Mono</exception>
        </member>
        <member name="M:LLCryptoLib.Utils.ClipboardUtils.Get">
            <summary>
            Get text string from clipboard
            </summary>
            <returns>text string from clipboard</returns>
            <exception cref="T:LLCryptoLib.LLCryptoLibException">This method is not supported in Mono</exception>
        </member>
        <member name="T:LLCryptoLib.Shred.ShredRandom">
            <summary>
            Rewrites the file area 5 times with random bytes
            </summary>
        </member>
        <member name="M:LLCryptoLib.Shred.ShredRandom.#ctor">
            <summary>
            ShredRandom constructor
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredRandom.Name">
            <summary>
            Shred Method Name
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredRandom.Id">
            <summary>
            Shred Enum ID
            </summary>
        </member>
        <member name="P:LLCryptoLib.Shred.ShredRandom.Description">
            <summary>
            Returns "Five times overwrite the file area with a sequence of pseudorandom bits"
            </summary>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.LLCertificateStore">
            <summary>
            A wrapper around <see cref="T:LLCryptoLib.Security.Certificates.CertificateStore"/>.
            Adds name and file path, plus a <see cref="T:LLCryptoLib.Security.Certificates.StoreLocation"/>
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificateStore.DeleteCertificateStore(LLCryptoLib.Security.Certificates.StoreLocation,System.String)">
            <summary>
            Deletes a certificate store.
            </summary>
            <param name="location">The store location as in <see cref="T:LLCryptoLib.Security.Certificates.StoreLocation"/></param>
            <param name="name">The name of the store</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificateStore.#ctor(LLCryptoLib.Security.Certificates.StoreLocation,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.LLCertificateStore"/> class.
            </summary>
            <param name="location">The location of the store</param>
            <param name="store">The name of the store to open.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificateStore.#ctor(LLCryptoLib.Security.Certificates.CertificateStore)">
            <summary>
            Create an LLCertificateStore from a CertificateStore.
            This will be a read only certificate.
            </summary>
            <param name="store">The certificate store.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificateStore.#ctor(LLCryptoLib.Security.Certificates.CertificateStore,System.String,LLCryptoLib.Security.Certificates.StoreLocation)">
            <summary>
            Create an LLCertificateStore from a CertificateStore, specifying attributes.
            </summary>
            <param name="store">The certificate Store</param>
            <param name="sname">The store name.</param>
            <param name="location">The store location as in <see cref="T:LLCryptoLib.Security.Certificates.StoreLocation"/></param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificateStore.#ctor(LLCryptoLib.Security.Certificates.CertificateStore,System.String,System.String,LLCryptoLib.Security.Certificates.StoreLocation)">
            <summary>
            Create an LLCertificateStore from a CertificateStore, specifying attributes.
            This will be a writable certificate.
            </summary>
            <param name="store">The certificate store.</param>
            <param name="spath">Folder in which saving certificates (may be temporary)</param>
            <param name="sname">The certificate store name.</param>
            <param name="location">The certificate store location.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.LLCertificateStore.SaveCertificateStoreFile">
            <summary>
            Temporary save of the certificate store certificate
            </summary>
            <returns>The full path of the certificate store file</returns>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificateStore.Location">
            <summary>
            Gets or sets the location.
            </summary>
            <value>The location.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificateStore.ReadOnly">
            <summary>
            Gets or sets a value indicating whether [read only].
            </summary>
            <value><c>true</c> if [read only]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificateStore.Path">
            <summary>
            Gets the path.
            </summary>
            <value>The path.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificateStore.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificateStore.RegistryKey">
            <summary>
            Gets the relativ store location in the registry.
            </summary>
            <value>The store registry key (relative to SOFTWARE\).</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.LLCertificateStore.SerialNumber">
            <summary>
            Gets the serial number.
            The serial number is the SHA1 of the certificate name + certificate location
            </summary>
            <value>The serial number of this certificate store.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.DistinguishedNameList">
            <summary>
            Implements a collection of <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> instances.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.#ctor">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/> instance.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.#ctor(System.Collections.ArrayList)">
            <summary>
            Initializes a new <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/> instance.
            </summary>
            <param name="state">The initial state of the collection.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="state"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.Add(LLCryptoLib.Security.Certificates.DistinguishedName)">
            <summary>
            Adds a <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> to the end of the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <param name="value">The <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> to be added to the end of the DistinguishedNameList.</param>
            <returns>The list index at which the value has been added.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.NotSupportedException">The list is read-only -or- the list has a fixed size.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.Clear">
            <summary>
            Removes all elements from the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The list is read-only -or- the list has a fixed size.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.Contains(LLCryptoLib.Security.Certificates.DistinguishedName)">
            <summary>
            Determines whether an element is in the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <param name="value">The Object to locate in the DistinguishedNameList. The element to locate cannot be a null reference (<b>Nothing</b> in Visual Basic).</param>
            <returns><b>true</b> if item is found in the DistinguishedNameList; otherwise, <b>false</b>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.IndexOf(LLCryptoLib.Security.Certificates.DistinguishedName)">
            <summary>
            Searches for the specified <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> and returns the zero-based index of the first occurrence within the entire <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <param name="value">The DistinguishedName to locate in the DistinguishedNameList.</param>
            <returns>The zero-based index of the first occurrence of value within the entire DistinguishedNameList, if found; otherwise, -1.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.Insert(System.Int32,LLCryptoLib.Security.Certificates.DistinguishedName)">
            <summary>
            Inserts an element into the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="value"/> should be inserted.</param>
            <param name="value">The <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> to insert. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero -or- <paramref name="index"/> is greater than <see cref="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.Count"/>.</exception>
            <exception cref="T:System.NotSupportedException">The DistinguishedNameList is read-only -or- the DistinguishedNameList has a fixed size.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.Remove(LLCryptoLib.Security.Certificates.DistinguishedName)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <param name="value">The <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> to remove from the DistinguishedNameList.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.NotSupportedException">The DistinguishedNameList is read-only -or- the DistinguishedNameList has a fixed size.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero -or- <paramref name="index"/> is greater than <see cref="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.Count"/>.</exception>
            <exception cref="T:System.NotSupportedException">The DistinguishedNameList is read-only -or- the DistinguishedNameList has a fixed size.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the entire <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/> to a compatible one-dimensional <see cref="T:System.Array"/>, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements copied from DistinguishedNameList. The Array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="array"/> is multidimensional -or- <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/> -or- the number of elements in the source DistinguishedNameList is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination array.</exception>
            <exception cref="T:System.InvalidCastException">The type of the source DistinguishedNameList cannot be cast automatically to the type of the destination array.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.GetEnumerator">
            <summary>
            Returns an enumerator for the entire <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <returns>An IEnumerator for the entire ArrayList.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedNameList.Clone">
            <summary>
            Creates a shallow copy of the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <returns>A shallow copy of the DistinguishedNameList.</returns>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.DistinguishedNameList.m_List">
            <summary>
            Holds the internal list.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/> has a fixed size.
            </summary>
            <value><b>true</b> if the ArrayList has a fixed size; otherwise, <b>false</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/> is read-only.
            </summary>
            <value><b>true</b> if the ArrayList is read-only; otherwise, <b>false</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <value>The element at the specified index.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is a null reference (<b>Nothing</b> in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero -or- <paramref name="index"/> is equal to or greater than <see cref="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.Count"/>.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.Count">
            <summary>
            Gets the number of elements actually contained in the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <value>The number of elements actually contained in the DistinguishedNameList.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/> is synchronized (thread-safe).
            </summary>
            <value><b>true</b> if access to the DistinguishedNameList is synchronized (thread-safe); otherwise, <b>false</b>.</value>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedNameList.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedNameList"/>.
            </summary>
            <value>An object that can be used to synchronize access to the DistinguishedNameList.</value>
        </member>
        <member name="T:LLCryptoLib.Security.Certificates.DistinguishedName">
            <summary>
            Represents a Relative Distinguished Name (RDN) of a <see cref="T:LLCryptoLib.Security.Certificates.Certificate"/>.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> class.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.#ctor(LLCryptoLib.Security.CertificateNameInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> class.
            </summary>
            <param name="cni">A <see cref="T:LLCryptoLib.Security.CertificateNameInfo"/> instance that's used to initialize the object.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> class.
            </summary>
            <param name="input">A pointer to a buffer that's used to initialize the object.</param>
            <param name="length">The length of the buffer.</param>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">Could not decode the buffer.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.Initialize(LLCryptoLib.Security.CertificateNameInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Security.Certificates.DistinguishedName"/> class with a given <see cref="T:LLCryptoLib.Security.CertificateNameInfo"/> instance.
            </summary>
            <param name="cni">The CertificateNameInfo instance to initialize from.</param>
            <exception cref="T:LLCryptoLib.Security.Certificates.CertificateException">An error occurs while initializeing the DistinguishedName object.</exception>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.Add(LLCryptoLib.Security.Certificates.NameAttribute)">
            <summary>
            Adds a <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/> to the end of the list.
            </summary>
            <param name="attribute">The NameAttribute to be added to the end of the list. </param>
            <returns>The index at which the value has been added.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.Clear">
            <summary>
            Removes all elements from the list.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.Contains(LLCryptoLib.Security.Certificates.NameAttribute)">
            <summary>
            Determines whether an element is in the list.
            </summary>
            <param name="value">The <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/> to locate in the list.</param>
            <returns><b>true</b> if item is found in the list; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.IndexOf(LLCryptoLib.Security.Certificates.NameAttribute)">
            <summary>
            Searches for the specified Object and returns the zero-based index of the first occurrence within the entire list.
            </summary>
            <param name="value">The <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/> to locate in the list.</param>
            <returns>The zero-based index of the first occurrence of value within the entire list, if found; otherwise, -1.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.IndexOf(System.String)">
            <summary>
            Searches for an Object with the specified Object identifier and returns the zero-based index of the first occurrence within the entire list.
            </summary>
            <param name="oid">The object identifier to search for.</param>
            <returns>The zero-based index of the first occurrence of value within the entire list, if found; otherwise, -1.</returns>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.Insert(System.Int32,LLCryptoLib.Security.Certificates.NameAttribute)">
            <summary>
            Inserts an element into the list at the specified index.
            </summary>
            <param name="index">The zero-based index at which value should be inserted.</param>
            <param name="value">The <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/> to insert.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.Remove(LLCryptoLib.Security.Certificates.NameAttribute)">
            <summary>
            Removes the first occurrence of a specific element from the list.
            </summary>
            <param name="value">The <see cref="T:LLCryptoLib.Security.Certificates.NameAttribute"/> to remove from the list.</param>
        </member>
        <member name="M:LLCryptoLib.Security.Certificates.DistinguishedName.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the list.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
        </member>
        <member name="F:LLCryptoLib.Security.Certificates.DistinguishedName.m_List">
            <summary>
            The internal list instance.
            </summary>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedName.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero -or- <paramref name="index"/> is equal to or greater than <see cref="P:LLCryptoLib.Security.Certificates.DistinguishedName.Count"/>.</exception>
        </member>
        <member name="P:LLCryptoLib.Security.Certificates.DistinguishedName.Count">
            <summary>
            Gets the number of elements actually contained in the list.
            </summary>
            <value>The number of elements actually contained in the list.</value>
        </member>
        <member name="T:LLCryptoLib.Hash.SHA512">
            <summary>Computes the SHA512 hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA512.#ctor">
            <summary>Initializes a new instance of the SHA512 class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA512.Initialize">
            <summary>Initializes the algorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA512.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.SHA512.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Hash.JHash">
            <summary>Computes the Jenkins Hash for the input data using the managed library.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.JHash.#ctor">
            <summary>Initializes a new instance of the JHash class.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.JHash.Initialize">
            <summary>Initializes an implementation of System.Security.Cryptography.HashAlgorithm.</summary>
        </member>
        <member name="M:LLCryptoLib.Hash.JHash.ProcessBlock(System.Byte[],System.Int32)">
            <summary>Process a block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
        </member>
        <member name="M:LLCryptoLib.Hash.JHash.ProcessFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process the last block of data.</summary>
            <param name="inputBuffer">The block of data to process.</param>
            <param name="inputOffset">Where to start in the block.</param>
            <param name="inputCount">How many bytes need to be processed.</param>
            <returns>The hash code as an array of bytes</returns>
        </member>
        <member name="T:LLCryptoLib.Crypto.XOR">
            <summary>
            XOR simple encryption algorithm.
            XOR, also know as Exclusive OR, is a bitwise operator from binary mathematics.
            The XOR operator returns a 1 when the value of either the first bit or the second bit is a 1.
            The XOR operator returns a 0 when neither or both of the bits is 1.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LLCryptoLib.Crypto.XOR"/> class.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates the encryptor.
            </summary>
            <param name="key">The key.</param>
            <param name="iv">The iv.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Creates the decryptor.
            </summary>
            <param name="key">The key.</param>
            <param name="iv">The iv.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.GenerateIV">
            <summary>
            Generates the IV.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.GenerateKey">
            <summary>
            Generates the key.
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.Dispose">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the block.
            </summary>
            <param name="inputBuffer">The input buffer.</param>
            <param name="inputOffset">The input offset.</param>
            <param name="inputCount">The input count.</param>
            <param name="outputBuffer">The output buffer.</param>
            <param name="outputOffset">The output offset.</param>
            <returns></returns>
        </member>
        <member name="M:LLCryptoLib.Crypto.XOR.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the final block.
            </summary>
            <param name="inputBuffer">The input buffer.</param>
            <param name="inputOffset">The input offset.</param>
            <param name="inputCount">The input count.</param>
            <returns></returns>
        </member>
        <member name="P:LLCryptoLib.Crypto.XOR.CanReuseTransform">
            <summary>
            Gets a value indicating whether this instance can reuse transform.
            </summary>
            <value>
            	<c>true</c> if this instance can reuse transform; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LLCryptoLib.Crypto.XOR.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether this instance can transform multiple blocks.
            </summary>
            <value>
            	<c>true</c> if this instance can transform multiple blocks; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LLCryptoLib.Crypto.XOR.InputBlockSize">
            <summary>
            Gets the size of the input block.
            </summary>
            <value>The size of the input block.</value>
        </member>
        <member name="P:LLCryptoLib.Crypto.XOR.OutputBlockSize">
            <summary>
            Gets the size of the output block.
            </summary>
            <value>The size of the output block.</value>
        </member>
    </members>
</doc>
