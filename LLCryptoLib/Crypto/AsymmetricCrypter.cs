using System;
using System.IO;
using System.Security.Cryptography;
using LLCryptoLib.Hash;
using LLCryptoLib.Security.Certificates;
using LLCryptoLib.Utils;
#if MONO
using Mono.Security.Cryptography;
#endif

namespace LLCryptoLib.Crypto
{
    /// <summary>
    ///     Asymmetric Crypter class.
    ///     This class implements RSA public key encryption. Public key means that a message encrypted
    ///     with a recipient's public key cannot be decrypted by anyone except the recipient possessing
    ///     the corresponding private key. To make such encryption, AsymmetricCrypter implements
    ///     RSA algorithm. Since this algorithm is relatively computationally costly in comparison with many
    ///     symmetric key algorithms of equivalent security, AsymmetricCrypter implements an
    ///     hybrid asymmetric/symmetric cryptosystem for reasons of efficiency; in such a
    ///     cryptosystem, a shared secret key ("session key") is generated by one party and this much briefer
    ///     session key is then encrypted by each recipient's public key. Each recipient uses the corresponding
    ///     private key to decrypt the session key. The message is then encrypted with a symmetric algorithm
    ///     ciphered with the session key. This is why the constructor of AsymmetricCrypter takes in input
    ///     a <see cref="SupportedStreamAlgorithms" /> object, to determine the symmetric algorithm that will
    ///     be used to encrypt the message. Instead, the random generated key is ciphered with RSA algorithm.
    ///     This class also offers some utility methods to acquire public and private keys from certificates
    ///     or external files in several formats, such as: CER, PEM or XML.
    /// </summary>
    /// <example>
    ///     Encryption code:
    ///     <code>
    /// AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
    /// RSA pubKey = AsymmetricCrypter.LoadKeyFromXmlFile(PUBLIC_KEY);
    /// // or RSA pubKey = AsymmetricCrypter.LoadPublicKeyFromCER(PUBLIC_KEY_CER);
    /// ac.Encrypt(new FileInfo(INPUT_FILE), new FileInfo(ENCRYPTED_FILE), pubKey);
    /// </code>
    /// </example>
    /// <example>
    ///     Decryption code:
    ///     <code>
    /// string storeName = "MyCA";
    /// string certificateName = "Alice";
    /// RSA privateKey = AsymmetricCrypter.LoadPrivateKey(StoreLocation.CurrentUser, storeName, certificateName);  
    /// AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
    /// ac.Decrypt(new FileInfo(ENCRYPTED_FILE), new FileInfo(DECRYPTED_FILE), privateKey);
    /// </code>
    /// </example>
    public class AsymmetricCrypter
    {
        private const int RANDOM_KEY_LEN = 20;
        private const int CACHESIZE = 2048;
        private readonly SupportedStreamAlgorithms ssa;

        /// <summary>
        ///     Initializes a new instance of the <see cref="AsymmetricCrypter" /> class.
        ///     Encryption will be done by generating a "session key" that will be encrypted
        ///     using the public key of the receiver. Then the message will be encrypted
        ///     using <see cref="SupportedStreamAlgorithms" /> algorithm with the encrypted
        ///     key.
        ///     To decrypt the message, the receiver will decrypt the session key (pre-pended
        ///     to the message, using her private key. Then she will use the session key in
        ///     clear to decrypt the message using <see cref="SupportedStreamAlgorithms" /> algorithm.
        /// </summary>
        /// <param name="encryptionAlgorithm">The symmetric encryption algorithm.</param>
        public AsymmetricCrypter(SupportedStreamAlgorithms encryptionAlgorithm)
        {
            this.ssa = encryptionAlgorithm;
        }

        /// <summary>
        ///     Encrypts the specified input file and saves the encrypted bytes in the
        ///     specified output file. To do so, a "session key" will be
        ///     randomly generated and then encrypted using the publick key of the receiver.
        ///     The public key may be obtained by a digital certificate, using a
        ///     <see cref="LLCryptoLib.Security.Certificates.LLCertificate" /> object.
        ///     Then the message will be encrypted then using <see cref="SupportedStreamAlgorithms" />
        ///     algorithm supplied in the constructor with the encrypted key.
        /// </summary>
        /// <param name="inputFile">The input file.</param>
        /// <param name="outputFile">The output file.</param>
        /// <param name="rsaPublicKey">The receiver public key.</param>
        /// <exception cref="ArgumentNullException" />
        /// <exception cref="ArgumentException">Input file does not exist or has zero length</exception>
        /// <example>
        ///     <code>
        /// AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
        /// RSA pubKey = AsymmetricCrypter.LoadKeyFromXmlFile(PUBLIC_KEY);
        /// // or RSA pubKey = AsymmetricCrypter.LoadPublicKeyFromCER(PUBLIC_KEY_CER);
        /// ac.Encrypt(new FileInfo(INPUT_FILE), new FileInfo(ENCRYPTED_FILE), pubKey);
        /// </code>
        /// </example>
        //public void Encrypt(FileInfo inputFile, FileInfo outputFile, RSACryptoServiceProvider rsaPublicKey)
        public void Encrypt(FileInfo inputFile, FileInfo outputFile, RSA rsaPublicKey)
        {
            if (rsaPublicKey == null)
            {
                throw new ArgumentNullException("rsaPublicKey");
            }

            if (inputFile == null)
            {
                throw new ArgumentNullException("inputFile");
            }

            if (outputFile == null)
            {
                throw new ArgumentNullException("outputFile");
            }

            if (!inputFile.Exists || (inputFile.Length == 0))
            {
                throw new ArgumentException("Input file does not exist.");
            }

            System.Diagnostics.Debug.WriteLine("Encrypting input file...");
            // Encrypt and save files
            this.Encrypt(inputFile.FullName, outputFile.FullName, rsaPublicKey);

            // Clear the RSA key.
            rsaPublicKey.Clear();
        }

        /// <summary>
        ///     Loads the public key from a CER certificate file.
        /// </summary>
        /// <param name="cerFile">The CER certificate file.</param>
        /// <returns>An RSA object containing the Public Key.</returns>
        /// <exception cref="LLCryptoLibException">File Too Long</exception>
        public static RSA LoadPublicKeyFromCer(string cerFile)
        {
            RSA rsaKey = null;
            FileManager fm = FileManager.Reference;
            byte[] cerFileBytes = fm.ReadBinaryFile(cerFile);
            if (cerFileBytes != null)
            {
                Certificate cert = Certificate.CreateFromCerFile(cerFileBytes);
                rsaKey = cert.PublicKey;
            }
            else
            {
                throw new LLCryptoLibException("Cannot load " + cerFile + ": " + fm.ErrorMessage);
            }

            return rsaKey;
        }

        /// <summary>
        ///     Loads the public key from a a PEM certificate file.
        /// </summary>
        /// <param name="pemFile">The PEM certificate file.</param>
        /// <returns>An RSA object containing the Public Key.</returns>
        /// <exception cref="LLCryptoLibException">File Too Long</exception>
        public static RSA LoadPublicKeyFromPem(string pemFile)
        {
            RSA rsaKey = null;
            FileManager fm = FileManager.Reference;
            byte[] pemFileBytes = fm.ReadBinaryFile(pemFile);
            if (pemFileBytes != null)
            {
                Certificate cert = Certificate.CreateFromPemFile(pemFileBytes);
                rsaKey = cert.PublicKey;
            }
            else
            {
                throw new LLCryptoLibException("Cannot load " + pemFile + ": " + fm.ErrorMessage);
            }
            return rsaKey;
        }

        /// <summary>
        ///     Loads the public key (and optionally the private key) from an XML file.
        ///     The XML file must adhere to the RSAKeyValue XML schema.
        /// </summary>
        /// <param name="rsaEncryptor">An object implementing RSA, as <see cref="RSACryptoServiceProvider" />.</param>
        /// <param name="publicKeyFile">The public/private key file as XML file.</param>
        /// <returns>
        ///     An RSA object containing the key
        /// </returns>
        /// <exception cref="LLCryptoLibException">Public Key format not recognized.</exception>
        public static RSA LoadKeyFromXmlFile(RSA rsaEncryptor, string publicKeyFile)
        {
            System.Diagnostics.Debug.WriteLine("Reading PUBLIC KEY OF RECEIVER...");
            FileManager fm = FileManager.Reference;
            string xmlFile = fm.ReadTextFile(publicKeyFile);
            if (xmlFile == null)
            {
                System.Diagnostics.Debug.WriteLine("LLCrypoLib AsymmetricCrypter.LoadPublicKey ERROR");
                System.Diagnostics.Debug.WriteLine(fm.ErrorMessage);
                throw new LLCryptoLibException("Error loading public key: " + fm.ErrorMessage);
            }

            return KeyFromXml(rsaEncryptor, xmlFile);
        }

        /// <summary>
        ///     Creates an RSA key or pair of keys (public or public with private) from an XML string.
        ///     The XML string must adhere to the RSAKeyValue XML schema.
        /// </summary>
        /// <param name="rsaEncryptor">An object implementing RSA, as <see cref="RSACryptoServiceProvider" />.</param>
        /// <param name="xmlCertificate">The public/private key file as XML string.</param>
        /// <returns>
        ///     An RSA object containing the key.
        /// </returns>
        /// <exception cref="LLCryptoLibException">Public Key format not recognized.</exception>
        /// <exception cref="ArgumentNullException" />
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability",
             "CA2000:DisposeObjectsBeforeLosingScope")]
        public static RSA KeyFromXml(RSA rsaEncryptor, string xmlCertificate)
        {
            if (rsaEncryptor == null)
            {
                throw new ArgumentNullException("rsaEncryptor");
            }

            if (xmlCertificate == null)
            {
                throw new ArgumentNullException("xmlCertificate");
            }

            if (xmlCertificate.StartsWith("<RSAKeyValue>"))
            {
                rsaEncryptor.FromXmlString(xmlCertificate);
                System.Diagnostics.Debug.WriteLine("Done reading public key.");
            }
            else
            {
                rsaEncryptor = null;
                throw new LLCryptoLibException("Public Key format not recognized.");
            }

            return rsaEncryptor;
        }

        /// <summary>
        ///     Signs the specified original file.
        /// </summary>
        /// <param name="originalFile">The original file.</param>
        /// <param name="signedFile">The signed file.</param>
        /// <param name="privateKey">The private key.</param>
        /// <param name="hash">The hash.</param>
        public static void Sign(FileInfo originalFile, FileInfo signedFile, RSA privateKey, AvailableHash hash)
        {
            Sign(originalFile.FullName, signedFile.FullName, privateKey, HashAlgorithm(hash));
        }

        /// <summary>
        ///     Verifies the signature.
        /// </summary>
        /// <param name="signedFile">The signed file.</param>
        /// <param name="publicKey">The public key of the signer</param>
        /// <param name="hash">The hash.</param>
        /// <param name="removeSignature">if set to <c>true</c> [remove signature].</param>
        /// <returns></returns>
        public static bool VerifySignature(FileInfo signedFile, RSA publicKey, AvailableHash hash, bool removeSignature)
        {
            return VerifySignature(signedFile.FullName, publicKey, HashAlgorithm(hash), removeSignature);
        }

        private static HashAlgorithm HashAlgorithm(AvailableHash hash)
        {
            SupportedHashAlgo hasher;
            switch (hash)
            {
                case AvailableHash.MD5:
                    hasher = SupportedHashAlgoFactory.GetAlgo(AvailableHash.MD5);
                    break;

                case AvailableHash.SHA1:
                    hasher = SupportedHashAlgoFactory.GetAlgo(AvailableHash.SHA1);
                    break;

                default:
                    throw new LLCryptoLibException("Unsupported Hash function for RSA");
            }

            return hasher.Algorithm;
        }

        /// <summary>
        ///     Decrypts the specified encrypted file in the specified output file, using the
        ///     provided private key.
        ///     Decryption is be done by reading an encrypted "session key" from the encrypted
        ///     file and then decrypting using the private key of the receiver. If the session key
        ///     is successfully decrypted, then the message will be decrypted
        ///     using <see cref="SupportedStreamAlgorithms" /> algorithm with the decrypted session
        ///     key.
        /// </summary>
        /// <example>
        ///     <code>
        /// string storeName = "MyCA";
        /// string certificateName = "Alice";
        /// RSA privateKey = AsymmetricCrypter.LoadPrivateKey(StoreLocation.CurrentUser, storeName, certificateName);  
        /// AsymmetricCrypter ac = new AsymmetricCrypter(SupportedStreamAlgorithms.BLOWFISH256);
        /// ac.Decrypt(new FileInfo(ENCRYPTED_FILE), new FileInfo(DECRYPTED_FILE), privateKey);
        /// </code>
        /// </example>
        /// <param name="encryptedFile">The encrypted file.</param>
        /// <param name="outputFile">The output file.</param>
        /// <param name="rsaPrivateKey">The RSA private key.</param>
        /// <exception cref="ArgumentNullException" />
        /// <exception cref="ArgumentException">Input file does not exist.</exception>
        public void Decrypt(FileInfo encryptedFile, FileInfo outputFile, RSA rsaPrivateKey)
        {
            if (encryptedFile == null)
            {
                throw new ArgumentNullException("encryptedFile");
            }

            if (rsaPrivateKey == null)
            {
                throw new ArgumentNullException("rsaPrivateKey");
            }

            if (outputFile == null)
            {
                throw new ArgumentNullException("outputFile");
            }

            if (!encryptedFile.Exists || (encryptedFile.Length == 0))
            {
                throw new ArgumentException("Input file does not exist.");
            }

            System.Diagnostics.Debug.WriteLine("Decrypting " + encryptedFile.FullName + "...");

            // Decrypt the elements.
            this.Decrypt(encryptedFile.FullName, outputFile.FullName, rsaPrivateKey);

            // Display the encrypted XML to the console.
            System.Diagnostics.Debug.WriteLine("File Decrypted.");

            // Clear the RSA key.
            rsaPrivateKey.Clear();
        }

        /// <summary>
        ///     Imports the private key from certificate.
        /// </summary>
        /// <param name="certificatePfx">The certificate PFX.</param>
        /// <param name="password">The password.</param>
        /// <returns>The private key as an RSA object</returns>
        /// <exception cref="LLCryptoLibException">This certificate contains no private key.</exception>
        public static RSA ImportPrivateKeyFromCertificate(string certificatePfx, string password)
        {
            RSA privateKey = null;
            Certificate cert = Certificate.CreateFromPfxFile(certificatePfx, password);

            if (cert.HasPrivateKey())
            {
                privateKey = cert.PrivateKey;
            }
            else
            {
                throw new LLCryptoLibException("This certificate contains no private key.");
            }

            return privateKey;
        }


        /// <summary>
        ///     Loads a private key from a certificate stored in the registry.
        /// </summary>
        /// <param name="location">The store location.</param>
        /// <param name="storeName">Name of the store in registry.</param>
        /// <param name="certificateName">Subject string of the certificate.</param>
        /// <returns>The private key as an RSA object.</returns>
        public static RSA LoadPrivateKey(StoreLocation location,
            string storeName,
            string certificateName)
        {
            System.Diagnostics.Debug.WriteLine("Reading PRIVATE KEY from " + storeName + "...");
            LLCertificateStore axsStore = new LLCertificateStore(location, storeName);
            Certificate cert = axsStore.FindCertificateBySubjectString(certificateName);
            System.Diagnostics.Debug.WriteLine("Done (" + cert.PrivateKey.KeySize + " bytes).");
            return cert.PrivateKey;
        }

        private StreamCrypter InitializeSymmetricAlgo(string rndKey)
        {
            IStreamAlgorithm cryptoAlgo = StreamAlgorithmFactory.Create(this.ssa);
            StreamCrypter crypter = new StreamCrypter(cryptoAlgo);
            crypter.GenerateKeys(rndKey);
            return crypter;
        }

        /// <summary>
        ///     <remarks>Implement CHUNK READ of original file</remarks>
        /// </summary>
        /// <param name="inFile"></param>
        /// <param name="publicKey"></param>
        /// <param name="hashAlgorithm"></param>
        /// <param name="removeSignature"></param>
        /// <returns></returns>
        private static bool VerifySignature(string inFile, RSA publicKey, object hashAlgorithm, bool removeSignature)
        {
            bool verification = false;
            RSACryptoServiceProvider rsaObj = publicKey as RSACryptoServiceProvider;

            using (FileStream inFs = new FileStream(inFile, FileMode.Open, FileAccess.ReadWrite))
            {
                // Extract signature
                byte[] signature = new byte[128];
                int originalFileLen = (int) inFs.Length - 128;
                byte[] originalFile = new byte[originalFileLen];
                inFs.Read(originalFile, 0, originalFileLen);
                int bsRead = inFs.Read(signature, 0, 128);
                if (bsRead == 128)
                {
                    System.Diagnostics.Debug.WriteLine("Signature is: " + Hexer.BytesToHex(signature, HexEnum.CLASSIC));
                    // Verify signature
                    verification = rsaObj.VerifyData(originalFile, hashAlgorithm, signature);
                }

                inFs.Flush();

                if (removeSignature)
                {
                    inFs.SetLength(inFs.Length - 128);
                }
            }

            return verification;
        }

        private static void Sign(string inFile, string outFile, RSA privateKey, object hashAlgorithm)
        {
            byte[] signedData = null;
            RSACryptoServiceProvider rsaObj = privateKey as RSACryptoServiceProvider;

            System.Diagnostics.Debug.WriteLine("Computing signature for " + inFile + "...");

            // Compute signature
            using (FileStream inFs = new FileStream(inFile, FileMode.Open, FileAccess.Read))
            {
                signedData = rsaObj.SignData(inFs, hashAlgorithm);
                System.Diagnostics.Debug.WriteLine("Signature size is " + signedData.Length);
                rsaObj.Clear();
            }

            // Save signature
            using (FileStream fx = new FileStream(inFile + ".sig", FileMode.Create, FileAccess.Write))
            {
                fx.Write(signedData, 0, signedData.Length);
            }

            System.Diagnostics.Debug.WriteLine("Signature is: " + Hexer.BytesToHex(signedData, HexEnum.CLASSIC));

            // Copy inFile to outfile and then append signature
            int len = 0;
            int rdlen = 0;
            byte[] bin = new byte[CACHESIZE];

            using (FileStream fin = new FileStream(inFile, FileMode.Open, FileAccess.Read))
            {
                using (FileStream fout = new FileStream(outFile, FileMode.Create, FileAccess.Write))
                {
                    System.Diagnostics.Debug.WriteLine("Signing " + outFile + " in-size: " + fin.Length);

                    while (rdlen < fin.Length)
                    {
                        len = fin.Read(bin, 0, CACHESIZE);
                        fout.Write(bin, 0, len);
                        rdlen += len;
                    }
                    fout.Write(signedData, 0, signedData.Length);
                }
            }

            using (FileStream fSigned = new FileStream(outFile, FileMode.Open, FileAccess.Read))
            {
                System.Diagnostics.Debug.WriteLine("Signed file is now " + fSigned.Length + " bytes.");
            }
        }

        private void Encrypt(string inFile, string outFile, RSA rsa)
        {
            // Generate random key
            string rndKey = RandomString.Get(RANDOM_KEY_LEN);

            // Initialize stream crypter
            StreamCrypter crypter = this.InitializeSymmetricAlgo(rndKey);

            // Use RSA to encrypt the key.
            byte[] clearKey = Hexer.Text2Bytes(rndKey);
            byte[] keyEncrypted;
            RSACryptoServiceProvider rsaObj = rsa as RSACryptoServiceProvider;
            if (rsaObj != null)
            {
                keyEncrypted = rsaObj.Encrypt(clearKey, false);
            }
            else
            {
                keyEncrypted = rsa.EncryptValue(clearKey);
            }

            int lKey = keyEncrypted.Length;
            byte[] keyLenBytes = new byte[4];
            keyLenBytes = BitConverter.GetBytes(lKey);

            using (FileStream outFs = new FileStream(outFile, FileMode.Create, FileAccess.Write))
            {
                // Write the encrypted key to the output stream
                outFs.Write(keyLenBytes, 0, 4);
                outFs.Write(keyEncrypted, 0, lKey);

                using (FileStream inFs = new FileStream(inFile, FileMode.Open, FileAccess.Read))
                {
                    crypter.EncryptDecrypt(inFs, outFs, true, null);
                }
            }
        }

        private void Decrypt(string inFile, string outFile, RSA rsa)
        {
            // This field will tell us how long is the encrypted key
            byte[] keyLen = new byte[4];

            // Use FileStream objects to read the encrypted
            // file (inFs) and save the decrypted file (outFs).
            using (FileStream inFs = new FileStream(inFile, FileMode.Open))
            {
                // Get the encrypted key from encrypted archive
                inFs.Seek(0, SeekOrigin.Begin);
                inFs.Read(keyLen, 0, 3);

                // Convert the lengths to integer values.
                int lenK = BitConverter.ToInt32(keyLen, 0);

                // Create the byte arrays for
                // the encrypted key.
                byte[] encryptedKey = new byte[lenK];

                // Extract the key 
                inFs.Seek(4, SeekOrigin.Begin);
                inFs.Read(encryptedKey, 0, lenK);

                // Use RSACryptoServiceProvider
                // to decrypt the Rijndael key.
                byte[] decryptedKey;
                RSACryptoServiceProvider rsaObj = rsa as RSACryptoServiceProvider;
                if (rsaObj != null)
                {
                    decryptedKey = rsaObj.Decrypt(encryptedKey, false);
                }
                else
                {
                    decryptedKey = rsa.DecryptValue(encryptedKey);
                }

                // Extract the key in clear
                string rndKey = Hexer.Bytes2Text(decryptedKey);

                // Initialize stream crypter
                StreamCrypter crypter = this.InitializeSymmetricAlgo(rndKey);

                using (FileStream outFs = new FileStream(outFile, FileMode.Create))
                {
                    crypter.EncryptDecrypt(inFs, outFs, false, null);
                }
            }
        }
    }


    /// <summary>
    ///     LLCryptoLib.Crypto library contains the functions to encrypt and decrypt
    ///     any stream or text file.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance",
         "CA1812:AvoidUninstantiatedInternalClasses")]
    internal class NamespaceDoc
    {
    }
}